/*! For license information please see 873.efc37b92.iframe.bundle.js.LICENSE.txt */
"use strict";(self.webpackChunkopen_sam_front=self.webpackChunkopen_sam_front||[]).push([[873],{"./node_modules/pixi.js/lib/app/init.mjs":(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{var Extensions=__webpack_require__("./node_modules/pixi.js/lib/extensions/Extensions.mjs");class ResizePlugin{static init(options){Object.defineProperty(this,"resizeTo",{configurable:!0,set(dom){globalThis.removeEventListener("resize",this.queueResize),this._resizeTo=dom,dom&&(globalThis.addEventListener("resize",this.queueResize),this.resize())},get(){return this._resizeTo}}),this.queueResize=()=>{this._resizeTo&&(this._cancelResize(),this._resizeId=requestAnimationFrame(()=>this.resize()))},this._cancelResize=()=>{this._resizeId&&(cancelAnimationFrame(this._resizeId),this._resizeId=null)},this.resize=()=>{if(!this._resizeTo)return;let width,height;if(this._cancelResize(),this._resizeTo===globalThis.window)width=globalThis.innerWidth,height=globalThis.innerHeight;else{const{clientWidth,clientHeight}=this._resizeTo;width=clientWidth,height=clientHeight}this.renderer.resize(width,height),this.render()},this._resizeId=null,this._resizeTo=null,this.resizeTo=options.resizeTo||null}static destroy(){globalThis.removeEventListener("resize",this.queueResize),this._cancelResize(),this._cancelResize=null,this.queueResize=null,this.resizeTo=null,this.resize=null}}ResizePlugin.extension=Extensions.Ag.Application;var ticker_const=__webpack_require__("./node_modules/pixi.js/lib/ticker/const.mjs"),Ticker=__webpack_require__("./node_modules/pixi.js/lib/ticker/Ticker.mjs");class TickerPlugin{static init(options){options=Object.assign({autoStart:!0,sharedTicker:!1},options),Object.defineProperty(this,"ticker",{configurable:!0,set(ticker){this._ticker&&this._ticker.remove(this.render,this),this._ticker=ticker,ticker&&ticker.add(this.render,this,ticker_const.d.LOW)},get(){return this._ticker}}),this.stop=()=>{this._ticker.stop()},this.start=()=>{this._ticker.start()},this._ticker=null,this.ticker=options.sharedTicker?Ticker.R.shared:new Ticker.R,options.autoStart&&this.start()}static destroy(){if(this._ticker){const oldTicker=this._ticker;this.ticker=null,oldTicker.destroy()}}}TickerPlugin.extension=Extensions.Ag.Application,Extensions.XO.add(ResizePlugin),Extensions.XO.add(TickerPlugin)},"./node_modules/pixi.js/lib/filters/Filter.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{d:()=>Filter});var _rendering_renderers_gl_shader_GlProgram_mjs__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs"),_rendering_renderers_gpu_shader_GpuProgram_mjs__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs"),_rendering_renderers_shared_shader_Shader_mjs__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs"),_rendering_renderers_shared_state_State_mjs__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs");const _Filter=class _Filter extends _rendering_renderers_shared_shader_Shader_mjs__WEBPACK_IMPORTED_MODULE_2__.M{constructor(options){super(options={..._Filter.defaultOptions,...options}),this.enabled=!0,this._state=_rendering_renderers_shared_state_State_mjs__WEBPACK_IMPORTED_MODULE_3__.U.for2d(),this.blendMode=options.blendMode,this.padding=options.padding,"boolean"==typeof options.antialias?this.antialias=options.antialias?"on":"off":this.antialias=options.antialias,this.resolution=options.resolution,this.blendRequired=options.blendRequired,this.clipToViewport=options.clipToViewport,this.addResource("uTexture",0,1),options.blendRequired&&this.addResource("uBackTexture",0,3)}apply(filterManager,input,output,clearMode){filterManager.applyFilter(this,input,output,clearMode)}get blendMode(){return this._state.blendMode}set blendMode(value){this._state.blendMode=value}static from(options){const{gpu,gl,...rest}=options;let gpuProgram,glProgram;return gpu&&(gpuProgram=_rendering_renderers_gpu_shader_GpuProgram_mjs__WEBPACK_IMPORTED_MODULE_1__.B.from(gpu)),gl&&(glProgram=_rendering_renderers_gl_shader_GlProgram_mjs__WEBPACK_IMPORTED_MODULE_0__.M.from(gl)),new _Filter({gpuProgram,glProgram,...rest})}};_Filter.defaultOptions={blendMode:"normal",resolution:1,padding:0,antialias:"off",blendRequired:!1,clipToViewport:!0};let Filter=_Filter},"./node_modules/pixi.js/lib/filters/init.mjs":(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{var Extensions=__webpack_require__("./node_modules/pixi.js/lib/extensions/Extensions.mjs");class FilterPipe{constructor(renderer){this._renderer=renderer}push(filterEffect,container,instructionSet){this._renderer.renderPipes.batch.break(instructionSet),instructionSet.add({renderPipeId:"filter",canBundle:!1,action:"pushFilter",container,filterEffect})}pop(_filterEffect,_container,instructionSet){this._renderer.renderPipes.batch.break(instructionSet),instructionSet.add({renderPipeId:"filter",action:"popFilter",canBundle:!1})}execute(instruction){"pushFilter"===instruction.action?this._renderer.filter.push(instruction):"popFilter"===instruction.action&&this._renderer.filter.pop()}destroy(){this._renderer=null}}FilterPipe.extension={type:[Extensions.Ag.WebGLPipes,Extensions.Ag.WebGPUPipes,Extensions.Ag.CanvasPipes],name:"filter"};var GlProgram=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs"),GpuProgram=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs"),Filter=__webpack_require__("./node_modules/pixi.js/lib/filters/Filter.mjs"),source="struct GlobalFilterUniforms {\n  uInputSize: vec4<f32>,\n  uInputPixel: vec4<f32>,\n  uInputClamp: vec4<f32>,\n  uOutputFrame: vec4<f32>,\n  uGlobalFrame: vec4<f32>,\n  uOutputTexture: vec4<f32>,\n};\n\n@group(0) @binding(0) var <uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler: sampler;\n\nstruct VSOutput {\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv: vec2<f32>\n};\n\nfn filterVertexPosition(aPosition: vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0 * gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord(aPosition: vec2<f32>) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition: vec2<f32>,\n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n) -> @location(0) vec4<f32> {\n    return textureSample(uTexture, uSampler, uv);\n}\n";class PassthroughFilter extends Filter.d{constructor(){super({gpuProgram:GpuProgram.B.from({vertex:{source,entryPoint:"mainVertex"},fragment:{source,entryPoint:"mainFragment"},name:"passthrough-filter"}),glProgram:GlProgram.M.from({vertex:"in vec2 aPosition;\nout vec2 vTextureCoord;\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n",fragment:"in vec2 vTextureCoord;\nout vec4 finalColor;\nuniform sampler2D uTexture;\nvoid main() {\n    finalColor = texture(uTexture, vTextureCoord);\n}\n",name:"passthrough-filter"})})}}var Matrix=__webpack_require__("./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs"),BindGroup=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs"),Geometry=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs"),UniformGroup=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs"),Texture=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs"),TexturePool=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs"),types=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/types.mjs"),Bounds=__webpack_require__("./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs");const tempProjectionMatrix=new Matrix.u;var warn=__webpack_require__("./node_modules/pixi.js/lib/utils/logging/warn.mjs");const quadGeometry=new Geometry.V({attributes:{aPosition:{buffer:new Float32Array([0,0,1,0,1,1,0,1]),format:"float32x2",stride:8,offset:0}},indexBuffer:new Uint32Array([0,1,2,0,2,3])});class FilterData{constructor(){this.skip=!1,this.inputTexture=null,this.backTexture=null,this.filters=null,this.bounds=new Bounds.c,this.container=null,this.blendRequired=!1,this.outputRenderSurface=null,this.globalFrame={x:0,y:0,width:0,height:0},this.firstEnabledIndex=-1,this.lastEnabledIndex=-1}}class FilterSystem{constructor(renderer){this._filterStackIndex=0,this._filterStack=[],this._filterGlobalUniforms=new UniformGroup.k({uInputSize:{value:new Float32Array(4),type:"vec4<f32>"},uInputPixel:{value:new Float32Array(4),type:"vec4<f32>"},uInputClamp:{value:new Float32Array(4),type:"vec4<f32>"},uOutputFrame:{value:new Float32Array(4),type:"vec4<f32>"},uGlobalFrame:{value:new Float32Array(4),type:"vec4<f32>"},uOutputTexture:{value:new Float32Array(4),type:"vec4<f32>"}}),this._globalFilterBindGroup=new BindGroup.T({}),this.renderer=renderer}get activeBackTexture(){return this._activeFilterData?.backTexture}push(instruction){const renderer=this.renderer,filters=instruction.filterEffect.filters,filterData=this._pushFilterData();filterData.skip=!1,filterData.filters=filters,filterData.container=instruction.container,filterData.outputRenderSurface=renderer.renderTarget.renderSurface;const colorTextureSource=renderer.renderTarget.renderTarget.colorTexture.source,rootResolution=colorTextureSource.resolution,rootAntialias=colorTextureSource.antialias;if(filters.every(filter=>!filter.enabled))return void(filterData.skip=!0);const bounds=filterData.bounds;if(this._calculateFilterArea(instruction,bounds),this._calculateFilterBounds(filterData,renderer.renderTarget.rootViewPort,rootAntialias,rootResolution,1),filterData.skip)return;const previousFilterData=this._getPreviousFilterData(),globalResolution=this._findFilterResolution(rootResolution);let offsetX=0,offsetY=0;previousFilterData&&(offsetX=previousFilterData.bounds.minX,offsetY=previousFilterData.bounds.minY),this._calculateGlobalFrame(filterData,offsetX,offsetY,globalResolution,colorTextureSource.width,colorTextureSource.height),this._setupFilterTextures(filterData,bounds,renderer,previousFilterData)}generateFilteredTexture({texture,filters}){const filterData=this._pushFilterData();this._activeFilterData=filterData,filterData.skip=!1,filterData.filters=filters;const colorTextureSource=texture.source,rootResolution=colorTextureSource.resolution,rootAntialias=colorTextureSource.antialias;if(filters.every(filter=>!filter.enabled))return filterData.skip=!0,texture;const bounds=filterData.bounds;if(bounds.addRect(texture.frame),this._calculateFilterBounds(filterData,bounds.rectangle,rootAntialias,rootResolution,0),filterData.skip)return texture;const globalResolution=rootResolution;this._calculateGlobalFrame(filterData,0,0,globalResolution,colorTextureSource.width,colorTextureSource.height),filterData.outputRenderSurface=TexturePool.W.getOptimalTexture(bounds.width,bounds.height,filterData.resolution,filterData.antialias),filterData.backTexture=Texture.g.EMPTY,filterData.inputTexture=texture;this.renderer.renderTarget.finishRenderPass(),this._applyFiltersToTexture(filterData,!0);const outputTexture=filterData.outputRenderSurface;return outputTexture.source.alphaMode="premultiplied-alpha",outputTexture}pop(){const renderer=this.renderer,filterData=this._popFilterData();filterData.skip||(renderer.globalUniforms.pop(),renderer.renderTarget.finishRenderPass(),this._activeFilterData=filterData,this._applyFiltersToTexture(filterData,!1),filterData.blendRequired&&TexturePool.W.returnTexture(filterData.backTexture),TexturePool.W.returnTexture(filterData.inputTexture))}getBackTexture(lastRenderSurface,bounds,previousBounds){const backgroundResolution=lastRenderSurface.colorTexture.source._resolution,backTexture=TexturePool.W.getOptimalTexture(bounds.width,bounds.height,backgroundResolution,!1);let x=bounds.minX,y=bounds.minY;previousBounds&&(x-=previousBounds.minX,y-=previousBounds.minY),x=Math.floor(x*backgroundResolution),y=Math.floor(y*backgroundResolution);const width=Math.ceil(bounds.width*backgroundResolution),height=Math.ceil(bounds.height*backgroundResolution);return this.renderer.renderTarget.copyToTexture(lastRenderSurface,backTexture,{x,y},{width,height},{x:0,y:0}),backTexture}applyFilter(filter,input,output,clear){const renderer=this.renderer,filterData=this._activeFilterData,isFinalTarget=filterData.outputRenderSurface===output,rootResolution=renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution,resolution=this._findFilterResolution(rootResolution);let offsetX=0,offsetY=0;if(isFinalTarget){const offset=this._findPreviousFilterOffset();offsetX=offset.x,offsetY=offset.y}this._updateFilterUniforms(input,output,filterData,offsetX,offsetY,resolution,isFinalTarget,clear);const filterToApply=filter.enabled?filter:this._getPassthroughFilter();this._setupBindGroupsAndRender(filterToApply,input,renderer)}calculateSpriteMatrix(outputMatrix,sprite){const data=this._activeFilterData,mappedMatrix=outputMatrix.set(data.inputTexture._source.width,0,0,data.inputTexture._source.height,data.bounds.minX,data.bounds.minY),worldTransform=sprite.worldTransform.copyTo(Matrix.u.shared),renderGroup=sprite.renderGroup||sprite.parentRenderGroup;return renderGroup&&renderGroup.cacheToLocalTransform&&worldTransform.prepend(renderGroup.cacheToLocalTransform),worldTransform.invert(),mappedMatrix.prepend(worldTransform),mappedMatrix.scale(1/sprite.texture.orig.width,1/sprite.texture.orig.height),mappedMatrix.translate(sprite.anchor.x,sprite.anchor.y),mappedMatrix}destroy(){this._passthroughFilter?.destroy(!0),this._passthroughFilter=null}_getPassthroughFilter(){return this._passthroughFilter??(this._passthroughFilter=new PassthroughFilter),this._passthroughFilter}_setupBindGroupsAndRender(filter,input,renderer){if(renderer.renderPipes.uniformBatch){const batchUniforms=renderer.renderPipes.uniformBatch.getUboResource(this._filterGlobalUniforms);this._globalFilterBindGroup.setResource(batchUniforms,0)}else this._globalFilterBindGroup.setResource(this._filterGlobalUniforms,0);this._globalFilterBindGroup.setResource(input.source,1),this._globalFilterBindGroup.setResource(input.source.style,2),filter.groups[0]=this._globalFilterBindGroup,renderer.encoder.draw({geometry:quadGeometry,shader:filter,state:filter._state,topology:"triangle-list"}),renderer.type===types.W.WEBGL&&renderer.renderTarget.finishRenderPass()}_setupFilterTextures(filterData,bounds,renderer,previousFilterData){if(filterData.backTexture=Texture.g.EMPTY,filterData.inputTexture=TexturePool.W.getOptimalTexture(bounds.width,bounds.height,filterData.resolution,filterData.antialias),filterData.blendRequired){renderer.renderTarget.finishRenderPass();const renderTarget=renderer.renderTarget.getRenderTarget(filterData.outputRenderSurface);filterData.backTexture=this.getBackTexture(renderTarget,bounds,previousFilterData?.bounds)}renderer.renderTarget.bind(filterData.inputTexture,!0),renderer.globalUniforms.push({offset:bounds})}_calculateGlobalFrame(filterData,offsetX,offsetY,globalResolution,sourceWidth,sourceHeight){const globalFrame=filterData.globalFrame;globalFrame.x=offsetX*globalResolution,globalFrame.y=offsetY*globalResolution,globalFrame.width=sourceWidth*globalResolution,globalFrame.height=sourceHeight*globalResolution}_updateFilterUniforms(input,output,filterData,offsetX,offsetY,resolution,isFinalTarget,clear){const uniforms=this._filterGlobalUniforms.uniforms,outputFrame=uniforms.uOutputFrame,inputSize=uniforms.uInputSize,inputPixel=uniforms.uInputPixel,inputClamp=uniforms.uInputClamp,globalFrame=uniforms.uGlobalFrame,outputTexture=uniforms.uOutputTexture;isFinalTarget?(outputFrame[0]=filterData.bounds.minX-offsetX,outputFrame[1]=filterData.bounds.minY-offsetY):(outputFrame[0]=0,outputFrame[1]=0),outputFrame[2]=input.frame.width,outputFrame[3]=input.frame.height,inputSize[0]=input.source.width,inputSize[1]=input.source.height,inputSize[2]=1/inputSize[0],inputSize[3]=1/inputSize[1],inputPixel[0]=input.source.pixelWidth,inputPixel[1]=input.source.pixelHeight,inputPixel[2]=1/inputPixel[0],inputPixel[3]=1/inputPixel[1],inputClamp[0]=.5*inputPixel[2],inputClamp[1]=.5*inputPixel[3],inputClamp[2]=input.frame.width*inputSize[2]-.5*inputPixel[2],inputClamp[3]=input.frame.height*inputSize[3]-.5*inputPixel[3];const rootTexture=this.renderer.renderTarget.rootRenderTarget.colorTexture;globalFrame[0]=offsetX*resolution,globalFrame[1]=offsetY*resolution,globalFrame[2]=rootTexture.source.width*resolution,globalFrame[3]=rootTexture.source.height*resolution,output instanceof Texture.g&&(output.source.resource=null);const renderTarget=this.renderer.renderTarget.getRenderTarget(output);this.renderer.renderTarget.bind(output,!!clear),output instanceof Texture.g?(outputTexture[0]=output.frame.width,outputTexture[1]=output.frame.height):(outputTexture[0]=renderTarget.width,outputTexture[1]=renderTarget.height),outputTexture[2]=renderTarget.isRoot?-1:1,this._filterGlobalUniforms.update()}_findFilterResolution(rootResolution){let currentIndex=this._filterStackIndex-1;for(;currentIndex>0&&this._filterStack[currentIndex].skip;)--currentIndex;return currentIndex>0&&this._filterStack[currentIndex].inputTexture?this._filterStack[currentIndex].inputTexture.source._resolution:rootResolution}_findPreviousFilterOffset(){let offsetX=0,offsetY=0,lastIndex=this._filterStackIndex;for(;lastIndex>0;){lastIndex--;const prevFilterData=this._filterStack[lastIndex];if(!prevFilterData.skip){offsetX=prevFilterData.bounds.minX,offsetY=prevFilterData.bounds.minY;break}}return{x:offsetX,y:offsetY}}_calculateFilterArea(instruction,bounds){if(instruction.renderables?function getGlobalRenderableBounds(renderables,bounds){bounds.clear();const actualMatrix=bounds.matrix;for(let i=0;i<renderables.length;i++){const renderable=renderables[i];if(renderable.globalDisplayStatus<7)continue;const renderGroup=renderable.renderGroup??renderable.parentRenderGroup;bounds.matrix=renderGroup?.isCachedAsTexture?tempProjectionMatrix.copyFrom(renderGroup.textureOffsetInverseTransform).append(renderable.worldTransform):renderGroup?._parentCacheAsTextureRenderGroup?tempProjectionMatrix.copyFrom(renderGroup._parentCacheAsTextureRenderGroup.inverseWorldTransform).append(renderable.groupTransform):renderable.worldTransform,bounds.addBounds(renderable.bounds)}return bounds.matrix=actualMatrix,bounds}(instruction.renderables,bounds):instruction.filterEffect.filterArea?(bounds.clear(),bounds.addRect(instruction.filterEffect.filterArea),bounds.applyMatrix(instruction.container.worldTransform)):instruction.container.getFastGlobalBounds(!0,bounds),instruction.container){const filterFrameTransform=(instruction.container.renderGroup||instruction.container.parentRenderGroup).cacheToLocalTransform;filterFrameTransform&&bounds.applyMatrix(filterFrameTransform)}}_applyFiltersToTexture(filterData,clear){const inputTexture=filterData.inputTexture,bounds=filterData.bounds,filters=filterData.filters,firstEnabled=filterData.firstEnabledIndex,lastEnabled=filterData.lastEnabledIndex;if(this._globalFilterBindGroup.setResource(inputTexture.source.style,2),this._globalFilterBindGroup.setResource(filterData.backTexture.source,3),firstEnabled===lastEnabled)filters[firstEnabled].apply(this,inputTexture,filterData.outputRenderSurface,clear);else{let flip=filterData.inputTexture;const tempTexture=TexturePool.W.getOptimalTexture(bounds.width,bounds.height,flip.source._resolution,!1);let flop=tempTexture;for(let i=firstEnabled;i<lastEnabled;i++){const filter=filters[i];if(!filter.enabled)continue;filter.apply(this,flip,flop,!0);const t=flip;flip=flop,flop=t}filters[lastEnabled].apply(this,flip,filterData.outputRenderSurface,clear),TexturePool.W.returnTexture(tempTexture)}}_calculateFilterBounds(filterData,viewPort,rootAntialias,rootResolution,paddingMultiplier){const renderer=this.renderer,bounds=filterData.bounds,filters=filterData.filters;let resolution=1/0,padding=0,antialias=!0,blendRequired=!1,enabled=!1,clipToViewport=!0,firstEnabledIndex=-1,lastEnabledIndex=-1;for(let i=0;i<filters.length;i++){const filter=filters[i];if(!filter.enabled)continue;-1===firstEnabledIndex&&(firstEnabledIndex=i),lastEnabledIndex=i,resolution=Math.min(resolution,"inherit"===filter.resolution?rootResolution:filter.resolution),padding+=filter.padding,"off"===filter.antialias?antialias=!1:"inherit"===filter.antialias&&antialias&&(antialias=rootAntialias),filter.clipToViewport||(clipToViewport=!1);if(!!!(filter.compatibleRenderers&renderer.type)){enabled=!1;break}if(filter.blendRequired&&!(renderer.backBuffer?.useBackBuffer??1)){(0,warn.R)("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options."),enabled=!1;break}enabled=!0,blendRequired||(blendRequired=filter.blendRequired)}enabled?(clipToViewport&&bounds.fitBounds(0,viewPort.width/rootResolution,0,viewPort.height/rootResolution),bounds.scale(resolution).ceil().scale(1/resolution).pad((0|padding)*paddingMultiplier),bounds.isPositive?(filterData.antialias=antialias,filterData.resolution=resolution,filterData.blendRequired=blendRequired,filterData.firstEnabledIndex=firstEnabledIndex,filterData.lastEnabledIndex=lastEnabledIndex):filterData.skip=!0):filterData.skip=!0}_popFilterData(){return this._filterStackIndex--,this._filterStack[this._filterStackIndex]}_getPreviousFilterData(){let previousFilterData,index=this._filterStackIndex-1;for(;index>0&&(index--,previousFilterData=this._filterStack[index],previousFilterData.skip););return previousFilterData}_pushFilterData(){let filterData=this._filterStack[this._filterStackIndex];return filterData||(filterData=this._filterStack[this._filterStackIndex]=new FilterData),this._filterStackIndex++,filterData}}FilterSystem.extension={type:[Extensions.Ag.WebGLSystem,Extensions.Ag.WebGPUSystem],name:"filter"},Extensions.XO.add(FilterSystem),Extensions.XO.add(FilterPipe)},"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Ls:()=>localUniformBit,_Q:()=>localUniformBitGroup2,mA:()=>localUniformBitGl});const localUniformBit={name:"local-uniform-bit",vertex:{header:"\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        ",main:"\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        ",end:"\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        "}},localUniformBitGroup2={...localUniformBit,vertex:{...localUniformBit.vertex,header:localUniformBit.vertex.header.replace("group(1)","group(2)")}},localUniformBitGl={name:"local-uniform-bit",vertex:{header:"\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        ",main:"\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        ",end:"\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        "}}},"./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{U:()=>State});const blendModeIds={normal:0,add:1,multiply:2,screen:3,overlay:4,erase:5,"normal-npm":6,"add-npm":7,"screen-npm":8,min:9,max:10},_State=class _State{constructor(){this.data=0,this.blendMode="normal",this.polygonOffset=0,this.blend=!0,this.depthMask=!0}get blend(){return!!(1&this.data)}set blend(value){!!(1&this.data)!==value&&(this.data^=1)}get offsets(){return!!(2&this.data)}set offsets(value){!!(2&this.data)!==value&&(this.data^=2)}set cullMode(value){"none"!==value?(this.culling=!0,this.clockwiseFrontFace="front"===value):this.culling=!1}get cullMode(){return this.culling?this.clockwiseFrontFace?"front":"back":"none"}get culling(){return!!(4&this.data)}set culling(value){!!(4&this.data)!==value&&(this.data^=4)}get depthTest(){return!!(8&this.data)}set depthTest(value){!!(8&this.data)!==value&&(this.data^=8)}get depthMask(){return!!(32&this.data)}set depthMask(value){!!(32&this.data)!==value&&(this.data^=32)}get clockwiseFrontFace(){return!!(16&this.data)}set clockwiseFrontFace(value){!!(16&this.data)!==value&&(this.data^=16)}get blendMode(){return this._blendMode}set blendMode(value){this.blend="none"!==value,this._blendMode=value,this._blendModeId=blendModeIds[value]||0}get polygonOffset(){return this._polygonOffset}set polygonOffset(value){this.offsets=!!value,this._polygonOffset=value}toString(){return`[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`}static for2d(){const state=new _State;return state.depthTest=!1,state.blend=!0,state}};_State.default2d=_State.for2d();let State=_State},"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{N:()=>CanvasPool});var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/pixi.js/lib/environment/adapter.mjs"),_maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/pixi.js/lib/maths/misc/pow2.mjs"),_utils_pool_GlobalResourceRegistry_mjs__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/pixi.js/lib/utils/pool/GlobalResourceRegistry.mjs");const CanvasPool=new class CanvasPoolClass{constructor(canvasOptions){this._canvasPool=Object.create(null),this.canvasOptions=canvasOptions||{},this.enableFullScreen=!1}_createCanvasAndContext(pixelWidth,pixelHeight){const canvas=_environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__.e.get().createCanvas();canvas.width=pixelWidth,canvas.height=pixelHeight;const context=canvas.getContext("2d");return{canvas,context}}getOptimalCanvasAndContext(minWidth,minHeight,resolution=1){minWidth=Math.ceil(minWidth*resolution-1e-6),minHeight=Math.ceil(minHeight*resolution-1e-6);const key=((minWidth=(0,_maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_1__.U5)(minWidth))<<17)+((minHeight=(0,_maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_1__.U5)(minHeight))<<1);this._canvasPool[key]||(this._canvasPool[key]=[]);let canvasAndContext=this._canvasPool[key].pop();return canvasAndContext||(canvasAndContext=this._createCanvasAndContext(minWidth,minHeight)),canvasAndContext}returnCanvasAndContext(canvasAndContext){const canvas=canvasAndContext.canvas,{width,height}=canvas,key=(width<<17)+(height<<1);canvasAndContext.context.resetTransform(),canvasAndContext.context.clearRect(0,0,width,height),this._canvasPool[key].push(canvasAndContext)}clear(){this._canvasPool={}}};_utils_pool_GlobalResourceRegistry_mjs__WEBPACK_IMPORTED_MODULE_2__.L.register(CanvasPool)},"./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{function color32BitToUniform(abgr,out,offset){const alpha=(abgr>>24&255)/255;out[offset++]=(255&abgr)/255*alpha,out[offset++]=(abgr>>8&255)/255*alpha,out[offset++]=(abgr>>16&255)/255*alpha,out[offset++]=alpha}__webpack_require__.d(__webpack_exports__,{V:()=>color32BitToUniform})},"./node_modules/pixi.js/lib/scene/graphics/init.mjs":(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{var Extensions=__webpack_require__("./node_modules/pixi.js/lib/extensions/Extensions.mjs"),GraphicsContextSystem=__webpack_require__("./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs"),State=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs"),PoolGroup=__webpack_require__("./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs"),colorToUniform=__webpack_require__("./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs"),BatchableGraphics=__webpack_require__("./node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs");class GraphicsGpuData{constructor(){this.batches=[],this.batched=!1}destroy(){this.batches.forEach(batch=>{PoolGroup.Z.return(batch)}),this.batches.length=0}}class GraphicsPipe{constructor(renderer,adaptor){this.state=State.U.for2d(),this.renderer=renderer,this._adaptor=adaptor,this.renderer.runners.contextChange.add(this)}contextChange(){this._adaptor.contextChange(this.renderer)}validateRenderable(graphics){const context=graphics.context,wasBatched=!!graphics._gpuData,gpuContext=this.renderer.graphicsContext.updateGpuContext(context);return!(!gpuContext.isBatchable&&wasBatched===gpuContext.isBatchable)}addRenderable(graphics,instructionSet){const gpuContext=this.renderer.graphicsContext.updateGpuContext(graphics.context);graphics.didViewUpdate&&this._rebuild(graphics),gpuContext.isBatchable?this._addToBatcher(graphics,instructionSet):(this.renderer.renderPipes.batch.break(instructionSet),instructionSet.add(graphics))}updateRenderable(graphics){const batches=this._getGpuDataForRenderable(graphics).batches;for(let i=0;i<batches.length;i++){const batch=batches[i];batch._batcher.updateElement(batch)}}execute(graphics){if(!graphics.isRenderable)return;const renderer=this.renderer,context=graphics.context;if(!renderer.graphicsContext.getGpuContext(context).batches.length)return;const shader=context.customShader||this._adaptor.shader;this.state.blendMode=graphics.groupBlendMode;const localUniforms=shader.resources.localUniforms.uniforms;localUniforms.uTransformMatrix=graphics.groupTransform,localUniforms.uRound=renderer._roundPixels|graphics._roundPixels,(0,colorToUniform.V)(graphics.groupColorAlpha,localUniforms.uColor,0),this._adaptor.execute(this,graphics)}_rebuild(graphics){const gpuData=this._getGpuDataForRenderable(graphics),gpuContext=this.renderer.graphicsContext.updateGpuContext(graphics.context);gpuData.destroy(),gpuContext.isBatchable&&this._updateBatchesForRenderable(graphics,gpuData)}_addToBatcher(graphics,instructionSet){const batchPipe=this.renderer.renderPipes.batch,batches=this._getGpuDataForRenderable(graphics).batches;for(let i=0;i<batches.length;i++){const batch=batches[i];batchPipe.addToBatch(batch,instructionSet)}}_getGpuDataForRenderable(graphics){return graphics._gpuData[this.renderer.uid]||this._initGpuDataForRenderable(graphics)}_initGpuDataForRenderable(graphics){const gpuData=new GraphicsGpuData;return graphics._gpuData[this.renderer.uid]=gpuData,gpuData}_updateBatchesForRenderable(graphics,gpuData){const context=graphics.context,gpuContext=this.renderer.graphicsContext.getGpuContext(context),roundPixels=this.renderer._roundPixels|graphics._roundPixels;gpuData.batches=gpuContext.batches.map(batch=>{const batchClone=PoolGroup.Z.get(BatchableGraphics.G);return batch.copyTo(batchClone),batchClone.renderable=graphics,batchClone.roundPixels=roundPixels,batchClone})}destroy(){this.renderer=null,this._adaptor.destroy(),this._adaptor=null,this.state=null}}GraphicsPipe.extension={type:[Extensions.Ag.WebGLPipes,Extensions.Ag.WebGPUPipes,Extensions.Ag.CanvasPipes],name:"graphics"},Extensions.XO.add(GraphicsPipe),Extensions.XO.add(GraphicsContextSystem.GH)},"./node_modules/pixi.js/lib/scene/mesh/init.mjs":(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{var Extensions=__webpack_require__("./node_modules/pixi.js/lib/extensions/Extensions.mjs"),Matrix=__webpack_require__("./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs"),BindGroup=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs"),UniformGroup=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs"),getAdjustedBlendModeBlend=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs"),colorToUniform=__webpack_require__("./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs"),BatchableMesh=__webpack_require__("./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs");class MeshGpuData{destroy(){}}class MeshPipe{constructor(renderer,adaptor){this.localUniforms=new UniformGroup.k({uTransformMatrix:{value:new Matrix.u,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),this.localUniformsBindGroup=new BindGroup.T({0:this.localUniforms}),this.renderer=renderer,this._adaptor=adaptor,this._adaptor.init()}validateRenderable(mesh){const meshData=this._getMeshData(mesh),wasBatched=meshData.batched,isBatched=mesh.batched;if(meshData.batched=isBatched,wasBatched!==isBatched)return!0;if(isBatched){const geometry=mesh._geometry;if(geometry.indices.length!==meshData.indexSize||geometry.positions.length!==meshData.vertexSize)return meshData.indexSize=geometry.indices.length,meshData.vertexSize=geometry.positions.length,!0;const batchableMesh=this._getBatchableMesh(mesh);return batchableMesh.texture.uid!==mesh._texture.uid&&(batchableMesh._textureMatrixUpdateId=-1),!batchableMesh._batcher.checkAndUpdateTexture(batchableMesh,mesh._texture)}return!1}addRenderable(mesh,instructionSet){const batcher=this.renderer.renderPipes.batch,meshData=this._getMeshData(mesh);if(mesh.didViewUpdate&&(meshData.indexSize=mesh._geometry.indices?.length,meshData.vertexSize=mesh._geometry.positions?.length),meshData.batched){const gpuBatchableMesh=this._getBatchableMesh(mesh);gpuBatchableMesh.setTexture(mesh._texture),gpuBatchableMesh.geometry=mesh._geometry,batcher.addToBatch(gpuBatchableMesh,instructionSet)}else batcher.break(instructionSet),instructionSet.add(mesh)}updateRenderable(mesh){if(mesh.batched){const gpuBatchableMesh=this._getBatchableMesh(mesh);gpuBatchableMesh.setTexture(mesh._texture),gpuBatchableMesh.geometry=mesh._geometry,gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh)}}execute(mesh){if(!mesh.isRenderable)return;mesh.state.blendMode=(0,getAdjustedBlendModeBlend.i)(mesh.groupBlendMode,mesh.texture._source);const localUniforms=this.localUniforms;localUniforms.uniforms.uTransformMatrix=mesh.groupTransform,localUniforms.uniforms.uRound=this.renderer._roundPixels|mesh._roundPixels,localUniforms.update(),(0,colorToUniform.V)(mesh.groupColorAlpha,localUniforms.uniforms.uColor,0),this._adaptor.execute(this,mesh)}_getMeshData(mesh){var _a,_b;return(_a=mesh._gpuData)[_b=this.renderer.uid]||(_a[_b]=new MeshGpuData),mesh._gpuData[this.renderer.uid].meshData||this._initMeshData(mesh)}_initMeshData(mesh){return mesh._gpuData[this.renderer.uid].meshData={batched:mesh.batched,indexSize:0,vertexSize:0},mesh._gpuData[this.renderer.uid].meshData}_getBatchableMesh(mesh){var _a,_b;return(_a=mesh._gpuData)[_b=this.renderer.uid]||(_a[_b]=new MeshGpuData),mesh._gpuData[this.renderer.uid].batchableMesh||this._initBatchableMesh(mesh)}_initBatchableMesh(mesh){const gpuMesh=new BatchableMesh.U;return gpuMesh.renderable=mesh,gpuMesh.setTexture(mesh._texture),gpuMesh.transform=mesh.groupTransform,gpuMesh.roundPixels=this.renderer._roundPixels|mesh._roundPixels,mesh._gpuData[this.renderer.uid].batchableMesh=gpuMesh,gpuMesh}destroy(){this.localUniforms=null,this.localUniformsBindGroup=null,this._adaptor.destroy(),this._adaptor=null,this.renderer=null}}MeshPipe.extension={type:[Extensions.Ag.WebGLPipes,Extensions.Ag.WebGPUPipes,Extensions.Ag.CanvasPipes],name:"mesh"},Extensions.XO.add(MeshPipe)},"./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{U:()=>BatchableMesh});class BatchableMesh{constructor(){this.batcherName="default",this.packAsQuad=!1,this.indexOffset=0,this.attributeOffset=0,this.roundPixels=0,this._batcher=null,this._batch=null,this._textureMatrixUpdateId=-1,this._uvUpdateId=-1}get blendMode(){return this.renderable.groupBlendMode}get topology(){return this._topology||this.geometry.topology}set topology(value){this._topology=value}reset(){this.renderable=null,this.texture=null,this._batcher=null,this._batch=null,this.geometry=null,this._uvUpdateId=-1,this._textureMatrixUpdateId=-1}setTexture(value){this.texture!==value&&(this.texture=value,this._textureMatrixUpdateId=-1)}get uvs(){const uvBuffer=this.geometry.getBuffer("aUV"),uvs=uvBuffer.data;let transformedUvs=uvs;const textureMatrix=this.texture.textureMatrix;return textureMatrix.isSimple||(transformedUvs=this._transformedUvs,this._textureMatrixUpdateId===textureMatrix._updateID&&this._uvUpdateId===uvBuffer._updateID||((!transformedUvs||transformedUvs.length<uvs.length)&&(transformedUvs=this._transformedUvs=new Float32Array(uvs.length)),this._textureMatrixUpdateId=textureMatrix._updateID,this._uvUpdateId=uvBuffer._updateID,textureMatrix.multiplyUvs(uvs,transformedUvs))),transformedUvs}get positions(){return this.geometry.positions}get indices(){return this.geometry.indices}get color(){return this.renderable.groupColorAlpha}get groupTransform(){return this.renderable.groupTransform}get attributeSize(){return this.geometry.positions.length/2}get indexSize(){return this.geometry.indices.length}}},"./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{u:()=>MeshGeometry});var _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs"),_rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs"),_rendering_renderers_shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs"),_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/pixi.js/lib/utils/logging/deprecation.mjs");const _MeshGeometry=class _MeshGeometry extends _rendering_renderers_shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_2__.V{constructor(...args){let options=args[0]??{};options instanceof Float32Array&&((0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_3__.t6)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_3__.lj,"use new MeshGeometry({ positions, uvs, indices }) instead"),options={positions:options,uvs:args[1],indices:args[2]}),options={..._MeshGeometry.defaultOptions,...options};const positions=options.positions||new Float32Array([0,0,1,0,1,1,0,1]);let uvs=options.uvs;uvs||(uvs=options.positions?new Float32Array(positions.length):new Float32Array([0,0,1,0,1,1,0,1]));const indices=options.indices||new Uint32Array([0,1,2,0,2,3]),shrinkToFit=options.shrinkBuffersToFit;super({attributes:{aPosition:{buffer:new _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_0__.h({data:positions,label:"attribute-mesh-positions",shrinkToFit,usage:_rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_1__.S.VERTEX|_rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_1__.S.COPY_DST}),format:"float32x2",stride:8,offset:0},aUV:{buffer:new _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_0__.h({data:uvs,label:"attribute-mesh-uvs",shrinkToFit,usage:_rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_1__.S.VERTEX|_rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_1__.S.COPY_DST}),format:"float32x2",stride:8,offset:0}},indexBuffer:new _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_0__.h({data:indices,label:"index-mesh-buffer",shrinkToFit,usage:_rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_1__.S.INDEX|_rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_1__.S.COPY_DST}),topology:options.topology}),this.batchMode="auto"}get positions(){return this.attributes.aPosition.buffer.data}set positions(value){this.attributes.aPosition.buffer.data=value}get uvs(){return this.attributes.aUV.buffer.data}set uvs(value){this.attributes.aUV.buffer.data=value}get indices(){return this.indexBuffer.data}set indices(value){this.indexBuffer.data=value}};_MeshGeometry.defaultOptions={topology:"triangle-list",shrinkBuffersToFit:!1};let MeshGeometry=_MeshGeometry},"./node_modules/pixi.js/lib/scene/particle-container/init.mjs":(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{var Extensions=__webpack_require__("./node_modules/pixi.js/lib/extensions/Extensions.mjs");class GlParticleContainerAdaptor{execute(particleContainerPipe,container){const state=particleContainerPipe.state,renderer=particleContainerPipe.renderer,shader=container.shader||particleContainerPipe.defaultShader;shader.resources.uTexture=container.texture._source,shader.resources.uniforms=particleContainerPipe.localUniforms;const gl=renderer.gl,buffer=particleContainerPipe.getBuffers(container);renderer.shader.bind(shader),renderer.state.set(state),renderer.geometry.bind(buffer.geometry,shader.glProgram);const glType=2===buffer.geometry.indexBuffer.data.BYTES_PER_ELEMENT?gl.UNSIGNED_SHORT:gl.UNSIGNED_INT;gl.drawElements(gl.TRIANGLES,6*container.particleChildren.length,glType,0)}}var Matrix=__webpack_require__("./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs"),UniformGroup=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs"),getAdjustedBlendModeBlend=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs"),State=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs"),colorToUniform=__webpack_require__("./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs"),Buffer=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs"),buffer_const=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs"),Geometry=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs"),getAttributeInfoFromFormat=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs"),ViewableBuffer=__webpack_require__("./node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs");function createIndicesForQuads(size,outBuffer=null){const totalIndices=6*size;if(totalIndices>65535?outBuffer||(outBuffer=new Uint32Array(totalIndices)):outBuffer||(outBuffer=new Uint16Array(totalIndices)),outBuffer.length!==totalIndices)throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);for(let i=0,j=0;i<totalIndices;i+=6,j+=4)outBuffer[i+0]=j+0,outBuffer[i+1]=j+1,outBuffer[i+2]=j+2,outBuffer[i+3]=j+0,outBuffer[i+4]=j+2,outBuffer[i+5]=j+3;return outBuffer}function generateUpdateFunction(properties,dynamic){const funcFragments=[];funcFragments.push("\n\n        var index = 0;\n\n        for (let i = 0; i < ps.length; ++i)\n        {\n            const p = ps[i];\n\n            ");let offset=0;for(const i in properties){const property=properties[i];if(dynamic!==property.dynamic)continue;funcFragments.push(`offset = index + ${offset}`),funcFragments.push(property.code);offset+=(0,getAttributeInfoFromFormat.m)(property.format).stride/4}funcFragments.push("\n            index += stride * 4;\n        }\n    "),funcFragments.unshift(`\n        var stride = ${offset};\n    `);const functionSource=funcFragments.join("\n");return new Function("ps","f32v","u32v",functionSource)}class ParticleBuffer{constructor(options){this._size=0,this._generateParticleUpdateCache={};const size=this._size=options.size??1e3,properties=options.properties;let staticVertexSize=0,dynamicVertexSize=0;for(const i in properties){const property=properties[i],attributeInfo=(0,getAttributeInfoFromFormat.m)(property.format);property.dynamic?dynamicVertexSize+=attributeInfo.stride:staticVertexSize+=attributeInfo.stride}this._dynamicStride=dynamicVertexSize/4,this._staticStride=staticVertexSize/4,this.staticAttributeBuffer=new ViewableBuffer.u(4*size*staticVertexSize),this.dynamicAttributeBuffer=new ViewableBuffer.u(4*size*dynamicVertexSize),this.indexBuffer=createIndicesForQuads(size);const geometry=new Geometry.V;let dynamicOffset=0,staticOffset=0;this._staticBuffer=new Buffer.h({data:new Float32Array(1),label:"static-particle-buffer",shrinkToFit:!1,usage:buffer_const.S.VERTEX|buffer_const.S.COPY_DST}),this._dynamicBuffer=new Buffer.h({data:new Float32Array(1),label:"dynamic-particle-buffer",shrinkToFit:!1,usage:buffer_const.S.VERTEX|buffer_const.S.COPY_DST});for(const i in properties){const property=properties[i],attributeInfo=(0,getAttributeInfoFromFormat.m)(property.format);property.dynamic?(geometry.addAttribute(property.attributeName,{buffer:this._dynamicBuffer,stride:4*this._dynamicStride,offset:4*dynamicOffset,format:property.format}),dynamicOffset+=attributeInfo.size):(geometry.addAttribute(property.attributeName,{buffer:this._staticBuffer,stride:4*this._staticStride,offset:4*staticOffset,format:property.format}),staticOffset+=attributeInfo.size)}geometry.addIndex(this.indexBuffer);const uploadFunction=this.getParticleUpdate(properties);this._dynamicUpload=uploadFunction.dynamicUpdate,this._staticUpload=uploadFunction.staticUpdate,this.geometry=geometry}getParticleUpdate(properties){const key=function getParticleSyncKey(properties){const keyGen=[];for(const key in properties){const property=properties[key];keyGen.push(key,property.code,property.dynamic?"d":"s")}return keyGen.join("_")}(properties);return this._generateParticleUpdateCache[key]||(this._generateParticleUpdateCache[key]=this.generateParticleUpdate(properties)),this._generateParticleUpdateCache[key]}generateParticleUpdate(properties){return function generateParticleUpdateFunction(properties){return{dynamicUpdate:generateUpdateFunction(properties,!0),staticUpdate:generateUpdateFunction(properties,!1)}}(properties)}update(particles,uploadStatic){particles.length>this._size&&(uploadStatic=!0,this._size=Math.max(particles.length,1.5*this._size|0),this.staticAttributeBuffer=new ViewableBuffer.u(this._size*this._staticStride*4*4),this.dynamicAttributeBuffer=new ViewableBuffer.u(this._size*this._dynamicStride*4*4),this.indexBuffer=createIndicesForQuads(this._size),this.geometry.indexBuffer.setDataWithSize(this.indexBuffer,this.indexBuffer.byteLength,!0));const dynamicAttributeBuffer=this.dynamicAttributeBuffer;if(this._dynamicUpload(particles,dynamicAttributeBuffer.float32View,dynamicAttributeBuffer.uint32View),this._dynamicBuffer.setDataWithSize(this.dynamicAttributeBuffer.float32View,particles.length*this._dynamicStride*4,!0),uploadStatic){const staticAttributeBuffer=this.staticAttributeBuffer;this._staticUpload(particles,staticAttributeBuffer.float32View,staticAttributeBuffer.uint32View),this._staticBuffer.setDataWithSize(staticAttributeBuffer.float32View,particles.length*this._staticStride*4,!0)}}destroy(){this._staticBuffer.destroy(),this._dynamicBuffer.destroy(),this.geometry.destroy()}}var Color=__webpack_require__("./node_modules/pixi.js/lib/color/Color.mjs"),GlProgram=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs"),GpuProgram=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs"),Shader=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs"),Texture=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs"),TextureStyle=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs"),wgsl="\nstruct ParticleUniforms {\n  uTranslationMatrix:mat3x3<f32>,\n  uColor:vec4<f32>,\n  uRound:f32,\n  uResolution:vec2<f32>,\n};\n\nfn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>\n{\n  return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n}\n\n@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;\n\n@group(1) @binding(0) var uTexture: texture_2d<f32>;\n@group(1) @binding(1) var uSampler : sampler;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) color : vec4<f32>,\n  };\n@vertex\nfn mainVertex(\n  @location(0) aVertex: vec2<f32>,\n  @location(1) aPosition: vec2<f32>,\n  @location(2) aUV: vec2<f32>,\n  @location(3) aColor: vec4<f32>,\n  @location(4) aRotation: f32,\n) -> VSOutput {\n  \n   let v = vec2(\n       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),\n       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)\n   ) + aPosition;\n\n   var position = vec4((uniforms.uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n   if(uniforms.uRound == 1.0) {\n       position = vec4(roundPixels(position.xy, uniforms.uResolution), position.zw);\n   }\n\n    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;\n\n  return VSOutput(\n   position,\n   aUV,\n   vColor,\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) color: vec4<f32>,\n  @builtin(position) position: vec4<f32>,\n) -> @location(0) vec4<f32> {\n\n    var sample = textureSample(uTexture, uSampler, uv) * color;\n   \n    return sample;\n}";class ParticleShader extends Shader.M{constructor(){super({glProgram:GlProgram.M.from({vertex:"attribute vec2 aVertex;\nattribute vec2 aUV;\nattribute vec4 aColor;\n\nattribute vec2 aPosition;\nattribute float aRotation;\n\nuniform mat3 uTranslationMatrix;\nuniform float uRound;\nuniform vec2 uResolution;\nuniform vec4 uColor;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\n\nvec2 roundPixels(vec2 position, vec2 targetSize)\n{       \n    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n}\n\nvoid main(void){\n    float cosRotation = cos(aRotation);\n    float sinRotation = sin(aRotation);\n    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;\n    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;\n\n    vec2 v = vec2(x, y);\n    v = v + aPosition;\n\n    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    if(uRound == 1.0)\n    {\n        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n    }\n\n    vUV = aUV;\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;\n}\n",fragment:"varying vec2 vUV;\nvarying vec4 vColor;\n\nuniform sampler2D uTexture;\n\nvoid main(void){\n    vec4 color = texture2D(uTexture, vUV) * vColor;\n    gl_FragColor = color;\n}"}),gpuProgram:GpuProgram.B.from({fragment:{source:wgsl,entryPoint:"mainFragment"},vertex:{source:wgsl,entryPoint:"mainVertex"}}),resources:{uTexture:Texture.g.WHITE.source,uSampler:new TextureStyle.n({}),uniforms:{uTranslationMatrix:{value:new Matrix.u,type:"mat3x3<f32>"},uColor:{value:new Color.Q(16777215),type:"vec4<f32>"},uRound:{value:1,type:"f32"},uResolution:{value:[0,0],type:"vec2<f32>"}}}})}}class ParticleContainerPipe{constructor(renderer,adaptor){this.state=State.U.for2d(),this.localUniforms=new UniformGroup.k({uTranslationMatrix:{value:new Matrix.u,type:"mat3x3<f32>"},uColor:{value:new Float32Array(4),type:"vec4<f32>"},uRound:{value:1,type:"f32"},uResolution:{value:[0,0],type:"vec2<f32>"}}),this.renderer=renderer,this.adaptor=adaptor,this.defaultShader=new ParticleShader,this.state=State.U.for2d()}validateRenderable(_renderable){return!1}addRenderable(renderable,instructionSet){this.renderer.renderPipes.batch.break(instructionSet),instructionSet.add(renderable)}getBuffers(renderable){return renderable._gpuData[this.renderer.uid]||this._initBuffer(renderable)}_initBuffer(renderable){return renderable._gpuData[this.renderer.uid]=new ParticleBuffer({size:renderable.particleChildren.length,properties:renderable._properties}),renderable._gpuData[this.renderer.uid]}updateRenderable(_renderable){}execute(container){const children=container.particleChildren;if(0===children.length)return;const renderer=this.renderer,buffer=this.getBuffers(container);container.texture||(container.texture=children[0].texture);const state=this.state;buffer.update(children,container._childrenDirty),container._childrenDirty=!1,state.blendMode=(0,getAdjustedBlendModeBlend.i)(container.blendMode,container.texture._source);const uniforms=this.localUniforms.uniforms,transformationMatrix=uniforms.uTranslationMatrix;container.worldTransform.copyTo(transformationMatrix),transformationMatrix.prepend(renderer.globalUniforms.globalUniformData.projectionMatrix),uniforms.uResolution=renderer.globalUniforms.globalUniformData.resolution,uniforms.uRound=renderer._roundPixels|container._roundPixels,(0,colorToUniform.V)(container.groupColorAlpha,uniforms.uColor,0),this.adaptor.execute(this,container)}destroy(){this.renderer=null,this.defaultShader&&(this.defaultShader.destroy(),this.defaultShader=null)}}class GlParticleContainerPipe extends ParticleContainerPipe{constructor(renderer){super(renderer,new GlParticleContainerAdaptor)}}GlParticleContainerPipe.extension={type:[Extensions.Ag.WebGLPipes],name:"particle"};class GpuParticleContainerAdaptor{execute(particleContainerPipe,container){const renderer=particleContainerPipe.renderer,shader=container.shader||particleContainerPipe.defaultShader;shader.groups[0]=renderer.renderPipes.uniformBatch.getUniformBindGroup(particleContainerPipe.localUniforms,!0),shader.groups[1]=renderer.texture.getTextureBindGroup(container.texture);const state=particleContainerPipe.state,buffer=particleContainerPipe.getBuffers(container);renderer.encoder.draw({geometry:buffer.geometry,shader:container.shader||particleContainerPipe.defaultShader,state,size:6*container.particleChildren.length})}}class GpuParticleContainerPipe extends ParticleContainerPipe{constructor(renderer){super(renderer,new GpuParticleContainerAdaptor)}}GpuParticleContainerPipe.extension={type:[Extensions.Ag.WebGPUPipes],name:"particle"},Extensions.XO.add(GlParticleContainerPipe),Extensions.XO.add(GpuParticleContainerPipe)},"./node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs":(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{var Extensions=__webpack_require__("./node_modules/pixi.js/lib/extensions/Extensions.mjs"),BatchableMesh=__webpack_require__("./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs"),deprecation=__webpack_require__("./node_modules/pixi.js/lib/utils/logging/deprecation.mjs"),MeshGeometry=__webpack_require__("./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs");const _PlaneGeometry=class _PlaneGeometry extends MeshGeometry.u{constructor(...args){super({});let options=args[0]??{};"number"==typeof options&&((0,deprecation.t6)(deprecation.lj,"PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead"),options={width:options,height:args[1],verticesX:args[2],verticesY:args[3]}),this.build(options)}build(options){options={..._PlaneGeometry.defaultOptions,...options},this.verticesX=this.verticesX??options.verticesX,this.verticesY=this.verticesY??options.verticesY,this.width=this.width??options.width,this.height=this.height??options.height;const total=this.verticesX*this.verticesY,verts=[],uvs=[],indices=[],verticesX=this.verticesX-1,verticesY=this.verticesY-1,sizeX=this.width/verticesX,sizeY=this.height/verticesY;for(let i=0;i<total;i++){const x=i%this.verticesX,y=i/this.verticesX|0;verts.push(x*sizeX,y*sizeY),uvs.push(x/verticesX,y/verticesY)}const totalSub=verticesX*verticesY;for(let i=0;i<totalSub;i++){const xpos=i%verticesX,ypos=i/verticesX|0,value=ypos*this.verticesX+xpos,value2=ypos*this.verticesX+xpos+1,value3=(ypos+1)*this.verticesX+xpos,value4=(ypos+1)*this.verticesX+xpos+1;indices.push(value,value2,value3,value2,value4,value3)}this.buffers[0].data=new Float32Array(verts),this.buffers[1].data=new Float32Array(uvs),this.indexBuffer.data=new Uint32Array(indices),this.buffers[0].update(),this.buffers[1].update(),this.indexBuffer.update()}};_PlaneGeometry.defaultOptions={width:100,height:100,verticesX:10,verticesY:10};let PlaneGeometry=_PlaneGeometry;const _NineSliceGeometry=class _NineSliceGeometry extends PlaneGeometry{constructor(options={}){super({width:(options={..._NineSliceGeometry.defaultOptions,...options}).width,height:options.height,verticesX:4,verticesY:4}),this.update(options)}update(options){this.width=options.width??this.width,this.height=options.height??this.height,this._originalWidth=options.originalWidth??this._originalWidth,this._originalHeight=options.originalHeight??this._originalHeight,this._leftWidth=options.leftWidth??this._leftWidth,this._rightWidth=options.rightWidth??this._rightWidth,this._topHeight=options.topHeight??this._topHeight,this._bottomHeight=options.bottomHeight??this._bottomHeight,this._anchorX=options.anchor?.x,this._anchorY=options.anchor?.y,this.updateUvs(),this.updatePositions()}updatePositions(){const p=this.positions,{width,height,_leftWidth,_rightWidth,_topHeight,_bottomHeight,_anchorX,_anchorY}=this,w=_leftWidth+_rightWidth,scaleW=width>w?1:width/w,h=_topHeight+_bottomHeight,scaleH=height>h?1:height/h,scale=Math.min(scaleW,scaleH),anchorOffsetX=_anchorX*width,anchorOffsetY=_anchorY*height;p[0]=p[8]=p[16]=p[24]=-anchorOffsetX,p[2]=p[10]=p[18]=p[26]=_leftWidth*scale-anchorOffsetX,p[4]=p[12]=p[20]=p[28]=width-_rightWidth*scale-anchorOffsetX,p[6]=p[14]=p[22]=p[30]=width-anchorOffsetX,p[1]=p[3]=p[5]=p[7]=-anchorOffsetY,p[9]=p[11]=p[13]=p[15]=_topHeight*scale-anchorOffsetY,p[17]=p[19]=p[21]=p[23]=height-_bottomHeight*scale-anchorOffsetY,p[25]=p[27]=p[29]=p[31]=height-anchorOffsetY,this.getBuffer("aPosition").update()}updateUvs(){const uvs=this.uvs;uvs[0]=uvs[8]=uvs[16]=uvs[24]=0,uvs[1]=uvs[3]=uvs[5]=uvs[7]=0,uvs[6]=uvs[14]=uvs[22]=uvs[30]=1,uvs[25]=uvs[27]=uvs[29]=uvs[31]=1;const _uvw=1/this._originalWidth,_uvh=1/this._originalHeight;uvs[2]=uvs[10]=uvs[18]=uvs[26]=_uvw*this._leftWidth,uvs[9]=uvs[11]=uvs[13]=uvs[15]=_uvh*this._topHeight,uvs[4]=uvs[12]=uvs[20]=uvs[28]=1-_uvw*this._rightWidth,uvs[17]=uvs[19]=uvs[21]=uvs[23]=1-_uvh*this._bottomHeight,this.getBuffer("aUV").update()}};_NineSliceGeometry.defaultOptions={width:100,height:100,leftWidth:10,topHeight:10,rightWidth:10,bottomHeight:10,originalWidth:100,originalHeight:100};let NineSliceGeometry=_NineSliceGeometry;class NineSliceSpriteGpuData extends BatchableMesh.U{constructor(){super(),this.geometry=new NineSliceGeometry}destroy(){this.geometry.destroy()}}class NineSliceSpritePipe{constructor(renderer){this._renderer=renderer}addRenderable(sprite,instructionSet){const gpuSprite=this._getGpuSprite(sprite);sprite.didViewUpdate&&this._updateBatchableSprite(sprite,gpuSprite),this._renderer.renderPipes.batch.addToBatch(gpuSprite,instructionSet)}updateRenderable(sprite){const gpuSprite=this._getGpuSprite(sprite);sprite.didViewUpdate&&this._updateBatchableSprite(sprite,gpuSprite),gpuSprite._batcher.updateElement(gpuSprite)}validateRenderable(sprite){const gpuSprite=this._getGpuSprite(sprite);return!gpuSprite._batcher.checkAndUpdateTexture(gpuSprite,sprite._texture)}_updateBatchableSprite(sprite,batchableSprite){batchableSprite.geometry.update(sprite),batchableSprite.setTexture(sprite._texture)}_getGpuSprite(sprite){return sprite._gpuData[this._renderer.uid]||this._initGPUSprite(sprite)}_initGPUSprite(sprite){const gpuData=sprite._gpuData[this._renderer.uid]=new NineSliceSpriteGpuData,batchableMesh=gpuData;return batchableMesh.renderable=sprite,batchableMesh.transform=sprite.groupTransform,batchableMesh.texture=sprite._texture,batchableMesh.roundPixels=this._renderer._roundPixels|sprite._roundPixels,sprite.didViewUpdate||this._updateBatchableSprite(sprite,batchableMesh),gpuData}destroy(){this._renderer=null}}NineSliceSpritePipe.extension={type:[Extensions.Ag.WebGLPipes,Extensions.Ag.WebGPUPipes,Extensions.Ag.CanvasPipes],name:"nineSliceSprite"},Extensions.XO.add(NineSliceSpritePipe)},"./node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs":(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{var Extensions=__webpack_require__("./node_modules/pixi.js/lib/extensions/Extensions.mjs"),getAdjustedBlendModeBlend=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs"),State=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs"),types=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/types.mjs"),colorToUniform=__webpack_require__("./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs"),BatchableMesh=__webpack_require__("./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs"),MeshGeometry=__webpack_require__("./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs"),Matrix=__webpack_require__("./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs"),compileHighShaderToProgram=__webpack_require__("./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs"),localUniformBit=__webpack_require__("./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs"),roundPixelsBit=__webpack_require__("./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs"),Shader=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs"),UniformGroup=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs"),Texture=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");const tilingBit={name:"tiling-bit",vertex:{header:"\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        ",main:"\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        "},fragment:{header:"\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        ",main:"\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            }\n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        "}},tilingBitGl={name:"tiling-bit",vertex:{header:"\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n\n        ",main:"\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        "},fragment:{header:"\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        ",main:"\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n\n        "}};let gpuProgram,glProgram;class TilingSpriteShader extends Shader.M{constructor(){gpuProgram??(gpuProgram=(0,compileHighShaderToProgram.v)({name:"tiling-sprite-shader",bits:[localUniformBit.Ls,tilingBit,roundPixelsBit.b]})),glProgram??(glProgram=(0,compileHighShaderToProgram.I)({name:"tiling-sprite-shader",bits:[localUniformBit.mA,tilingBitGl,roundPixelsBit.m]}));const tilingUniforms=new UniformGroup.k({uMapCoord:{value:new Matrix.u,type:"mat3x3<f32>"},uClampFrame:{value:new Float32Array([0,0,1,1]),type:"vec4<f32>"},uClampOffset:{value:new Float32Array([0,0]),type:"vec2<f32>"},uTextureTransform:{value:new Matrix.u,type:"mat3x3<f32>"},uSizeAnchor:{value:new Float32Array([100,100,.5,.5]),type:"vec4<f32>"}});super({glProgram,gpuProgram,resources:{localUniforms:new UniformGroup.k({uTransformMatrix:{value:new Matrix.u,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),tilingUniforms,uTexture:Texture.g.EMPTY.source,uSampler:Texture.g.EMPTY.source.style}})}updateUniforms(width,height,matrix,anchorX,anchorY,texture){const tilingUniforms=this.resources.tilingUniforms,textureWidth=texture.width,textureHeight=texture.height,textureMatrix=texture.textureMatrix,uTextureTransform=tilingUniforms.uniforms.uTextureTransform;uTextureTransform.set(matrix.a*textureWidth/width,matrix.b*textureWidth/height,matrix.c*textureHeight/width,matrix.d*textureHeight/height,matrix.tx/width,matrix.ty/height),uTextureTransform.invert(),tilingUniforms.uniforms.uMapCoord=textureMatrix.mapCoord,tilingUniforms.uniforms.uClampFrame=textureMatrix.uClampFrame,tilingUniforms.uniforms.uClampOffset=textureMatrix.uClampOffset,tilingUniforms.uniforms.uTextureTransform=uTextureTransform,tilingUniforms.uniforms.uSizeAnchor[0]=width,tilingUniforms.uniforms.uSizeAnchor[1]=height,tilingUniforms.uniforms.uSizeAnchor[2]=anchorX,tilingUniforms.uniforms.uSizeAnchor[3]=anchorY,texture&&(this.resources.uTexture=texture.source,this.resources.uSampler=texture.source.style)}}class QuadGeometry extends MeshGeometry.u{constructor(){super({positions:new Float32Array([0,0,1,0,1,1,0,1]),uvs:new Float32Array([0,0,1,0,1,1,0,1]),indices:new Uint32Array([0,1,2,0,2,3])})}}const sharedQuad=new QuadGeometry;class TilingSpriteGpuData{constructor(){this.canBatch=!0,this.geometry=new MeshGeometry.u({indices:sharedQuad.indices.slice(),positions:sharedQuad.positions.slice(),uvs:sharedQuad.uvs.slice()})}destroy(){this.geometry.destroy(),this.shader?.destroy()}}class TilingSpritePipe{constructor(renderer){this._state=State.U.default2d,this._renderer=renderer}validateRenderable(renderable){const tilingSpriteData=this._getTilingSpriteData(renderable),couldBatch=tilingSpriteData.canBatch;this._updateCanBatch(renderable);const canBatch=tilingSpriteData.canBatch;if(canBatch&&canBatch===couldBatch){const{batchableMesh}=tilingSpriteData;return!batchableMesh._batcher.checkAndUpdateTexture(batchableMesh,renderable.texture)}return couldBatch!==canBatch}addRenderable(tilingSprite,instructionSet){const batcher=this._renderer.renderPipes.batch;this._updateCanBatch(tilingSprite);const tilingSpriteData=this._getTilingSpriteData(tilingSprite),{geometry,canBatch}=tilingSpriteData;if(canBatch){tilingSpriteData.batchableMesh||(tilingSpriteData.batchableMesh=new BatchableMesh.U);const batchableMesh=tilingSpriteData.batchableMesh;tilingSprite.didViewUpdate&&(this._updateBatchableMesh(tilingSprite),batchableMesh.geometry=geometry,batchableMesh.renderable=tilingSprite,batchableMesh.transform=tilingSprite.groupTransform,batchableMesh.setTexture(tilingSprite._texture)),batchableMesh.roundPixels=this._renderer._roundPixels|tilingSprite._roundPixels,batcher.addToBatch(batchableMesh,instructionSet)}else batcher.break(instructionSet),tilingSpriteData.shader||(tilingSpriteData.shader=new TilingSpriteShader),this.updateRenderable(tilingSprite),instructionSet.add(tilingSprite)}execute(tilingSprite){const{shader}=this._getTilingSpriteData(tilingSprite);shader.groups[0]=this._renderer.globalUniforms.bindGroup;const localUniforms=shader.resources.localUniforms.uniforms;localUniforms.uTransformMatrix=tilingSprite.groupTransform,localUniforms.uRound=this._renderer._roundPixels|tilingSprite._roundPixels,(0,colorToUniform.V)(tilingSprite.groupColorAlpha,localUniforms.uColor,0),this._state.blendMode=(0,getAdjustedBlendModeBlend.i)(tilingSprite.groupBlendMode,tilingSprite.texture._source),this._renderer.encoder.draw({geometry:sharedQuad,shader,state:this._state})}updateRenderable(tilingSprite){const tilingSpriteData=this._getTilingSpriteData(tilingSprite),{canBatch}=tilingSpriteData;if(canBatch){const{batchableMesh}=tilingSpriteData;tilingSprite.didViewUpdate&&this._updateBatchableMesh(tilingSprite),batchableMesh._batcher.updateElement(batchableMesh)}else if(tilingSprite.didViewUpdate){const{shader}=tilingSpriteData;shader.updateUniforms(tilingSprite.width,tilingSprite.height,tilingSprite._tileTransform.matrix,tilingSprite.anchor.x,tilingSprite.anchor.y,tilingSprite.texture)}}_getTilingSpriteData(renderable){return renderable._gpuData[this._renderer.uid]||this._initTilingSpriteData(renderable)}_initTilingSpriteData(tilingSprite){const gpuData=new TilingSpriteGpuData;return gpuData.renderable=tilingSprite,tilingSprite._gpuData[this._renderer.uid]=gpuData,gpuData}_updateBatchableMesh(tilingSprite){const renderableData=this._getTilingSpriteData(tilingSprite),{geometry}=renderableData,style=tilingSprite.texture.source.style;"repeat"!==style.addressMode&&(style.addressMode="repeat",style.update()),function setUvs(tilingSprite,uvs){const texture=tilingSprite.texture,width=texture.frame.width,height=texture.frame.height;let anchorX=0,anchorY=0;tilingSprite.applyAnchorToTexture&&(anchorX=tilingSprite.anchor.x,anchorY=tilingSprite.anchor.y),uvs[0]=uvs[6]=-anchorX,uvs[2]=uvs[4]=1-anchorX,uvs[1]=uvs[3]=-anchorY,uvs[5]=uvs[7]=1-anchorY;const textureMatrix=Matrix.u.shared;textureMatrix.copyFrom(tilingSprite._tileTransform.matrix),textureMatrix.tx/=tilingSprite.width,textureMatrix.ty/=tilingSprite.height,textureMatrix.invert(),textureMatrix.scale(tilingSprite.width/width,tilingSprite.height/height),function applyMatrix(array,stride,offset,matrix){let index=0;const size=array.length/(stride||2),a=matrix.a,b=matrix.b,c=matrix.c,d=matrix.d,tx=matrix.tx,ty=matrix.ty;for(offset*=stride;index<size;){const x=array[offset],y=array[offset+1];array[offset]=a*x+c*y+tx,array[offset+1]=b*x+d*y+ty,offset+=stride,index++}}(uvs,2,0,textureMatrix)}(tilingSprite,geometry.uvs),function setPositions(tilingSprite,positions){const anchorX=tilingSprite.anchor.x,anchorY=tilingSprite.anchor.y;positions[0]=-anchorX*tilingSprite.width,positions[1]=-anchorY*tilingSprite.height,positions[2]=(1-anchorX)*tilingSprite.width,positions[3]=-anchorY*tilingSprite.height,positions[4]=(1-anchorX)*tilingSprite.width,positions[5]=(1-anchorY)*tilingSprite.height,positions[6]=-anchorX*tilingSprite.width,positions[7]=(1-anchorY)*tilingSprite.height}(tilingSprite,geometry.positions)}destroy(){this._renderer=null}_updateCanBatch(tilingSprite){const renderableData=this._getTilingSpriteData(tilingSprite),texture=tilingSprite.texture;let _nonPowOf2wrapping=!0;return this._renderer.type===types.W.WEBGL&&(_nonPowOf2wrapping=this._renderer.context.supports.nonPowOf2wrapping),renderableData.canBatch=texture.textureMatrix.isSimple&&(_nonPowOf2wrapping||texture.source.isPowerOfTwo),renderableData.canBatch}}TilingSpritePipe.extension={type:[Extensions.Ag.WebGLPipes,Extensions.Ag.WebGPUPipes,Extensions.Ag.CanvasPipes],name:"tilingSprite"},Extensions.XO.add(TilingSpritePipe)},"./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{K:()=>BatchableSprite});class BatchableSprite{constructor(){this.batcherName="default",this.topology="triangle-list",this.attributeSize=4,this.indexSize=6,this.packAsQuad=!0,this.roundPixels=0,this._attributeStart=0,this._batcher=null,this._batch=null}get blendMode(){return this.renderable.groupBlendMode}get color(){return this.renderable.groupColorAlpha}reset(){this.renderable=null,this.texture=null,this._batcher=null,this._batch=null,this.bounds=null}destroy(){}}},"./node_modules/pixi.js/lib/scene/text-bitmap/init.mjs":(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{var Extensions=__webpack_require__("./node_modules/pixi.js/lib/extensions/Extensions.mjs"),Cache=__webpack_require__("./node_modules/pixi.js/lib/assets/cache/Cache.mjs"),Graphics=__webpack_require__("./node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs"),CanvasTextMetrics=__webpack_require__("./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs"),Matrix=__webpack_require__("./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs"),compileHighShaderToProgram=__webpack_require__("./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs"),colorBit=__webpack_require__("./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs"),generateTextureBatchBit=__webpack_require__("./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs"),roundPixelsBit=__webpack_require__("./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs"),getBatchSamplersUniformGroup=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs"),Shader=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs"),UniformGroup=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs");const localUniformMSDFBit={name:"local-uniform-msdf-bit",vertex:{header:"\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        ",main:"\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        ",end:"\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        "},fragment:{header:"\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         ",main:"\n            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));\n        "}},localUniformMSDFBitGl={name:"local-uniform-msdf-bit",vertex:{header:"\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        ",main:"\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        ",end:"\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        "},fragment:{header:"\n            uniform float uDistance;\n         ",main:"\n            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));\n        "}},mSDFBit={name:"msdf-bit",fragment:{header:"\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {\n\n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));\n                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);\n                var coverage: f32 = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n\n            }\n        "}},mSDFBitGl={name:"msdf-bit",fragment:{header:"\n            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {\n\n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));\n                float gamma = mix(1.0, 1.0 / 2.2, luma);\n                float coverage = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n            }\n        "}};let gpuProgram,glProgram;class SdfShader extends Shader.M{constructor(maxTextures){const uniforms=new UniformGroup.k({uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uTransformMatrix:{value:new Matrix.u,type:"mat3x3<f32>"},uDistance:{value:4,type:"f32"},uRound:{value:0,type:"f32"}});gpuProgram??(gpuProgram=(0,compileHighShaderToProgram.v)({name:"sdf-shader",bits:[colorBit.F,(0,generateTextureBatchBit._)(maxTextures),localUniformMSDFBit,mSDFBit,roundPixelsBit.b]})),glProgram??(glProgram=(0,compileHighShaderToProgram.I)({name:"sdf-shader",bits:[colorBit.a,(0,generateTextureBatchBit.P)(maxTextures),localUniformMSDFBitGl,mSDFBitGl,roundPixelsBit.m]})),super({glProgram,gpuProgram,resources:{localUniforms:uniforms,batchSamplers:(0,getBatchSamplersUniformGroup.n)(maxTextures)}})}}var tiny_lru=__webpack_require__("./node_modules/tiny-lru/dist/tiny-lru.js"),deprecation=__webpack_require__("./node_modules/pixi.js/lib/utils/logging/deprecation.mjs"),warn=__webpack_require__("./node_modules/pixi.js/lib/utils/logging/warn.mjs"),TextStyle=__webpack_require__("./node_modules/pixi.js/lib/scene/text/TextStyle.mjs"),Color=__webpack_require__("./node_modules/pixi.js/lib/color/Color.mjs"),Rectangle=__webpack_require__("./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs"),CanvasPool=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs"),ImageSource=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs"),Texture=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs"),TextureStyle=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs"),fontStringFromTextStyle=__webpack_require__("./node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs"),getCanvasFillStyle=__webpack_require__("./node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs"),eventemitter3=__webpack_require__("./node_modules/eventemitter3/index.mjs");class AbstractBitmapFont extends eventemitter3.A{constructor(){super(...arguments),this.chars=Object.create(null),this.lineHeight=0,this.fontFamily="",this.fontMetrics={fontSize:0,ascent:0,descent:0},this.baseLineOffset=0,this.distanceField={type:"none",range:0},this.pages=[],this.applyFillAsTint=!0,this.baseMeasurementFontSize=100,this.baseRenderedFontSize=100}get font(){return(0,deprecation.t6)(deprecation.lj,"BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."),this.fontFamily}get pageTextures(){return(0,deprecation.t6)(deprecation.lj,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}get size(){return(0,deprecation.t6)(deprecation.lj,"BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."),this.fontMetrics.fontSize}get distanceFieldRange(){return(0,deprecation.t6)(deprecation.lj,"BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."),this.distanceField.range}get distanceFieldType(){return(0,deprecation.t6)(deprecation.lj,"BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."),this.distanceField.type}destroy(destroyTextures=!1){this.emit("destroy",this),this.removeAllListeners();for(const i in this.chars)this.chars[i].texture?.destroy();this.chars=null,destroyTextures&&(this.pages.forEach(page=>page.texture.destroy(!0)),this.pages=null)}}const _DynamicBitmapFont=class _DynamicBitmapFont extends AbstractBitmapFont{constructor(options){super(),this.resolution=1,this.pages=[],this._padding=0,this._measureCache=Object.create(null),this._currentChars=[],this._currentX=0,this._currentY=0,this._currentMaxCharHeight=0,this._currentPageIndex=-1,this._skipKerning=!1;const dynamicOptions={..._DynamicBitmapFont.defaultOptions,...options};this._textureSize=dynamicOptions.textureSize,this._mipmap=dynamicOptions.mipmap;const style=dynamicOptions.style.clone();dynamicOptions.overrideFill&&(style._fill.color=16777215,style._fill.alpha=1,style._fill.texture=Texture.g.WHITE,style._fill.fill=null),this.applyFillAsTint=dynamicOptions.overrideFill;const requestedFontSize=style.fontSize;style.fontSize=this.baseMeasurementFontSize;const font=(0,fontStringFromTextStyle.Z)(style);dynamicOptions.overrideSize?style._stroke&&(style._stroke.width*=this.baseRenderedFontSize/requestedFontSize):style.fontSize=this.baseRenderedFontSize=requestedFontSize,this._style=style,this._skipKerning=dynamicOptions.skipKerning??!1,this.resolution=dynamicOptions.resolution??1,this._padding=dynamicOptions.padding??4,dynamicOptions.textureStyle&&(this._textureStyle=dynamicOptions.textureStyle instanceof TextureStyle.n?dynamicOptions.textureStyle:new TextureStyle.n(dynamicOptions.textureStyle)),this.fontMetrics=CanvasTextMetrics.P.measureFont(font),this.lineHeight=style.lineHeight||this.fontMetrics.fontSize||style.fontSize}ensureCharacters(chars){const charList=CanvasTextMetrics.P.graphemeSegmenter(chars).filter(char=>!this._currentChars.includes(char)).filter((char,index,self)=>self.indexOf(char)===index);if(!charList.length)return;let pageData;this._currentChars=[...this._currentChars,...charList],pageData=-1===this._currentPageIndex?this._nextPage():this.pages[this._currentPageIndex];let{canvas,context}=pageData.canvasAndContext,textureSource=pageData.texture.source;const style=this._style;let currentX=this._currentX,currentY=this._currentY,currentMaxCharHeight=this._currentMaxCharHeight;const fontScale=this.baseRenderedFontSize/this.baseMeasurementFontSize,padding=this._padding*fontScale;let skipTexture=!1;const maxTextureWidth=canvas.width/this.resolution,maxTextureHeight=canvas.height/this.resolution;for(let i=0;i<charList.length;i++){const char=charList[i],metrics=CanvasTextMetrics.P.measureText(char,style,canvas,!1);metrics.lineHeight=metrics.height;const width=metrics.width*fontScale,paddedWidth=Math.ceil(("italic"===style.fontStyle?2:1)*width)+2*padding,paddedHeight=metrics.height*fontScale+2*padding;if(skipTexture=!1,"\n"!==char&&"\r"!==char&&"\t"!==char&&" "!==char&&(skipTexture=!0,currentMaxCharHeight=Math.ceil(Math.max(paddedHeight,currentMaxCharHeight))),currentX+paddedWidth>maxTextureWidth&&(currentY+=currentMaxCharHeight,currentMaxCharHeight=paddedHeight,currentX=0,currentY+currentMaxCharHeight>maxTextureHeight)){textureSource.update();const pageData2=this._nextPage();canvas=pageData2.canvasAndContext.canvas,context=pageData2.canvasAndContext.context,textureSource=pageData2.texture.source,currentX=0,currentY=0,currentMaxCharHeight=0}const xAdvance=width/fontScale-(style.dropShadow?.distance??0)-(style._stroke?.width??0);if(this.chars[char]={id:char.codePointAt(0),xOffset:-this._padding,yOffset:-this._padding,xAdvance,kerning:{}},skipTexture){this._drawGlyph(context,metrics,currentX+padding,currentY+padding,fontScale,style);const px=textureSource.width*fontScale,py=textureSource.height*fontScale,frame=new Rectangle.M(currentX/px*textureSource.width,currentY/py*textureSource.height,paddedWidth/px*textureSource.width,paddedHeight/py*textureSource.height);this.chars[char].texture=new Texture.g({source:textureSource,frame}),currentX+=Math.ceil(paddedWidth)}}textureSource.update(),this._currentX=currentX,this._currentY=currentY,this._currentMaxCharHeight=currentMaxCharHeight,this._skipKerning&&this._applyKerning(charList,context)}get pageTextures(){return(0,deprecation.t6)(deprecation.lj,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}_applyKerning(newChars,context){const measureCache=this._measureCache;for(let i=0;i<newChars.length;i++){const first=newChars[i];for(let j=0;j<this._currentChars.length;j++){const second=this._currentChars[j];let c1=measureCache[first];c1||(c1=measureCache[first]=context.measureText(first).width);let c2=measureCache[second];c2||(c2=measureCache[second]=context.measureText(second).width);let total=context.measureText(first+second).width,amount=total-(c1+c2);amount&&(this.chars[first].kerning[second]=amount),total=context.measureText(first+second).width,amount=total-(c1+c2),amount&&(this.chars[second].kerning[first]=amount)}}}_nextPage(){this._currentPageIndex++;const textureResolution=this.resolution,canvasAndContext=CanvasPool.N.getOptimalCanvasAndContext(this._textureSize,this._textureSize,textureResolution);this._setupContext(canvasAndContext.context,this._style,textureResolution);const resolution=textureResolution*(this.baseRenderedFontSize/this.baseMeasurementFontSize),texture=new Texture.g({source:new ImageSource.b({resource:canvasAndContext.canvas,resolution,alphaMode:"premultiply-alpha-on-upload",autoGenerateMipmaps:this._mipmap})});this._textureStyle&&(texture.source.style=this._textureStyle);const pageData={canvasAndContext,texture};return this.pages[this._currentPageIndex]=pageData,pageData}_setupContext(context,style,resolution){style.fontSize=this.baseRenderedFontSize,context.scale(resolution,resolution),context.font=(0,fontStringFromTextStyle.Z)(style),style.fontSize=this.baseMeasurementFontSize,context.textBaseline=style.textBaseline;const stroke=style._stroke,strokeThickness=stroke?.width??0;if(stroke&&(context.lineWidth=strokeThickness,context.lineJoin=stroke.join,context.miterLimit=stroke.miterLimit,context.strokeStyle=(0,getCanvasFillStyle.r)(stroke,context)),style._fill&&(context.fillStyle=(0,getCanvasFillStyle.r)(style._fill,context)),style.dropShadow){const shadowOptions=style.dropShadow,rgb=Color.Q.shared.setValue(shadowOptions.color).toArray(),dropShadowBlur=shadowOptions.blur*resolution,dropShadowDistance=shadowOptions.distance*resolution;context.shadowColor=`rgba(${255*rgb[0]},${255*rgb[1]},${255*rgb[2]},${shadowOptions.alpha})`,context.shadowBlur=dropShadowBlur,context.shadowOffsetX=Math.cos(shadowOptions.angle)*dropShadowDistance,context.shadowOffsetY=Math.sin(shadowOptions.angle)*dropShadowDistance}else context.shadowColor="black",context.shadowBlur=0,context.shadowOffsetX=0,context.shadowOffsetY=0}_drawGlyph(context,metrics,x,y,fontScale,style){const char=metrics.text,fontProperties=metrics.fontProperties,stroke=style._stroke,strokeThickness=(stroke?.width??0)*fontScale,tx=x+strokeThickness/2,ty=y-strokeThickness/2,descent=fontProperties.descent*fontScale,lineHeight=metrics.lineHeight*fontScale;let removeShadow=!1;style.stroke&&strokeThickness&&(removeShadow=!0,context.strokeText(char,tx,ty+lineHeight-descent));const{shadowBlur,shadowOffsetX,shadowOffsetY}=context;style._fill&&(removeShadow&&(context.shadowBlur=0,context.shadowOffsetX=0,context.shadowOffsetY=0),context.fillText(char,tx,ty+lineHeight-descent)),removeShadow&&(context.shadowBlur=shadowBlur,context.shadowOffsetX=shadowOffsetX,context.shadowOffsetY=shadowOffsetY)}destroy(){super.destroy();for(let i=0;i<this.pages.length;i++){const{canvasAndContext,texture}=this.pages[i];CanvasPool.N.returnCanvasAndContext(canvasAndContext),texture.destroy(!0)}this.pages=null}};_DynamicBitmapFont.defaultOptions={textureSize:512,style:new TextStyle.x,mipmap:!0};let DynamicBitmapFont=_DynamicBitmapFont;function getBitmapTextLayout(chars,style,font,trimEnd){const layoutData={width:0,height:0,offsetY:0,scale:style.fontSize/font.baseMeasurementFontSize,lines:[{width:0,charPositions:[],spaceWidth:0,spacesIndex:[],chars:[]}]};layoutData.offsetY=font.baseLineOffset;let currentLine=layoutData.lines[0],previousChar=null,firstWord=!0;const currentWord={spaceWord:!1,width:0,start:0,index:0,positions:[],chars:[]},scale=font.baseMeasurementFontSize/style.fontSize,adjustedLetterSpacing=style.letterSpacing*scale,adjustedWordWrapWidth=style.wordWrapWidth*scale,adjustedLineHeight=style.lineHeight?style.lineHeight*scale:font.lineHeight,breakWords=style.wordWrap&&style.breakWords,nextWord=word=>{const start=currentLine.width;for(let j=0;j<currentWord.index;j++){const position=word.positions[j];currentLine.chars.push(word.chars[j]),currentLine.charPositions.push(position+start)}currentLine.width+=word.width,firstWord=!1,currentWord.width=0,currentWord.index=0,currentWord.chars.length=0},nextLine=()=>{let index=currentLine.chars.length-1;if(trimEnd){let lastChar=currentLine.chars[index];for(;" "===lastChar;)currentLine.width-=font.chars[lastChar].xAdvance,lastChar=currentLine.chars[--index]}layoutData.width=Math.max(layoutData.width,currentLine.width),currentLine={width:0,charPositions:[],chars:[],spaceWidth:0,spacesIndex:[]},firstWord=!0,layoutData.lines.push(currentLine),layoutData.height+=adjustedLineHeight},checkIsOverflow=lineWidth=>lineWidth-adjustedLetterSpacing>adjustedWordWrapWidth;for(let i=0;i<chars.length+1;i++){let char;const isEnd=i===chars.length;isEnd||(char=chars[i]);const charData=font.chars[char]||font.chars[" "];if(/(?:\s)/.test(char)||"\r"===char||"\n"===char||isEnd){if(!firstWord&&style.wordWrap&&checkIsOverflow(currentLine.width+currentWord.width)?(nextLine(),nextWord(currentWord),isEnd||currentLine.charPositions.push(0)):(currentWord.start=currentLine.width,nextWord(currentWord),isEnd||currentLine.charPositions.push(0)),"\r"===char||"\n"===char)nextLine();else if(!isEnd){const spaceWidth=charData.xAdvance+(charData.kerning[previousChar]||0)+adjustedLetterSpacing;currentLine.width+=spaceWidth,currentLine.spaceWidth=spaceWidth,currentLine.spacesIndex.push(currentLine.charPositions.length),currentLine.chars.push(char)}}else{const kerning=charData.kerning[previousChar]||0,nextCharWidth=charData.xAdvance+kerning+adjustedLetterSpacing;breakWords&&checkIsOverflow(currentLine.width+currentWord.width+nextCharWidth)&&(nextWord(currentWord),nextLine()),currentWord.positions[currentWord.index++]=currentWord.width+kerning,currentWord.chars.push(char),currentWord.width+=nextCharWidth}previousChar=char}return nextLine(),"center"===style.align?function alignCenter(measurementData){for(let i=0;i<measurementData.lines.length;i++){const line=measurementData.lines[i],offset=measurementData.width/2-line.width/2;for(let j=0;j<line.charPositions.length;j++)line.charPositions[j]+=offset}}(layoutData):"right"===style.align?function alignRight(measurementData){for(let i=0;i<measurementData.lines.length;i++){const line=measurementData.lines[i],offset=measurementData.width-line.width;for(let j=0;j<line.charPositions.length;j++)line.charPositions[j]+=offset}}(layoutData):"justify"===style.align&&function alignJustify(measurementData){const width=measurementData.width;for(let i=0;i<measurementData.lines.length;i++){const line=measurementData.lines[i];let indy=0,spaceIndex=line.spacesIndex[indy++],offset=0;const totalSpaces=line.spacesIndex.length,spaceWidth=(width-line.width)/totalSpaces;for(let j=0;j<line.charPositions.length;j++)j===spaceIndex&&(spaceIndex=line.spacesIndex[indy++],offset+=spaceWidth),line.charPositions[j]+=offset}}(layoutData),layoutData}let fontCount=0;const BitmapFontManager=new class BitmapFontManagerClass{constructor(){this.ALPHA=[["a","z"],["A","Z"]," "],this.NUMERIC=[["0","9"]],this.ALPHANUMERIC=[["a","z"],["A","Z"],["0","9"]," "],this.ASCII=[[" ","~"]],this.defaultOptions={chars:this.ALPHANUMERIC,resolution:1,padding:4,skipKerning:!1,textureStyle:null},this.measureCache=(0,tiny_lru.g)(1e3)}getFont(text,style){let fontFamilyKey=`${style.fontFamily}-bitmap`,overrideFill=!0;if(style._fill.fill&&!style._stroke?(fontFamilyKey+=style._fill.fill.styleKey,overrideFill=!1):(style._stroke||style.dropShadow)&&(fontFamilyKey=`${style.styleKey}-bitmap`,overrideFill=!1),!Cache.l.has(fontFamilyKey)){const styleCopy=Object.create(style);styleCopy.lineHeight=0;const fnt=new DynamicBitmapFont({style:styleCopy,overrideFill,overrideSize:!0,...this.defaultOptions});fontCount++,fontCount>50&&(0,warn.R)("BitmapText",`You have dynamically created ${fontCount} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``),fnt.once("destroy",()=>{fontCount--,Cache.l.remove(fontFamilyKey)}),Cache.l.set(fontFamilyKey,fnt)}const dynamicFont=Cache.l.get(fontFamilyKey);return dynamicFont.ensureCharacters?.(text),dynamicFont}getLayout(text,style,trimEnd=!0){const bitmapFont=this.getFont(text,style),id=`${text}-${style.styleKey}-${trimEnd}`;if(this.measureCache.has(id))return this.measureCache.get(id);const layoutData=getBitmapTextLayout(CanvasTextMetrics.P.graphemeSegmenter(text),style,bitmapFont,trimEnd);return this.measureCache.set(id,layoutData),layoutData}measureText(text,style,trimEnd=!0){return this.getLayout(text,style,trimEnd)}install(...args){let options=args[0];"string"==typeof options&&(options={name:options,style:args[1],chars:args[2]?.chars,resolution:args[2]?.resolution,padding:args[2]?.padding,skipKerning:args[2]?.skipKerning},(0,deprecation.t6)(deprecation.lj,"BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})"));const name=options?.name;if(!name)throw new Error("[BitmapFontManager] Property `name` is required.");options={...this.defaultOptions,...options};const textStyle=options.style,style=textStyle instanceof TextStyle.x?textStyle:new TextStyle.x(textStyle),overrideFill=options.dynamicFill??this._canUseTintForStyle(style),font=new DynamicBitmapFont({style,overrideFill,skipKerning:options.skipKerning,padding:options.padding,resolution:options.resolution,overrideSize:!1,textureStyle:options.textureStyle}),flatChars=function resolveCharacters(chars){if(""===chars)return[];"string"==typeof chars&&(chars=[chars]);const result=[];for(let i=0,j=chars.length;i<j;i++){const item=chars[i];if(Array.isArray(item)){if(2!==item.length)throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);if(0===item[0].length||0===item[1].length)throw new Error("[BitmapFont]: Invalid character delimiter.");const startCode=item[0].charCodeAt(0),endCode=item[1].charCodeAt(0);if(endCode<startCode)throw new Error("[BitmapFont]: Invalid character range.");for(let i2=startCode,j2=endCode;i2<=j2;i2++)result.push(String.fromCharCode(i2))}else result.push(...Array.from(item))}if(0===result.length)throw new Error("[BitmapFont]: Empty set when resolving characters.");return result}(options.chars);return font.ensureCharacters(flatChars.join("")),Cache.l.set(`${name}-bitmap`,font),font.once("destroy",()=>Cache.l.remove(`${name}-bitmap`)),font}uninstall(name){const cacheKey=`${name}-bitmap`,font=Cache.l.get(cacheKey);font&&font.destroy()}_canUseTintForStyle(style){return!(style._stroke||style.dropShadow&&0!==style.dropShadow.color||style._fill.fill||16777215!==style._fill.color)}};class BitmapTextGraphics extends Graphics.A{destroy(){this.context.customShader&&this.context.customShader.destroy(),super.destroy()}}class BitmapTextPipe{constructor(renderer){this._renderer=renderer}validateRenderable(bitmapText){const graphicsRenderable=this._getGpuBitmapText(bitmapText);return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable)}addRenderable(bitmapText,instructionSet){const graphicsRenderable=this._getGpuBitmapText(bitmapText);syncWithProxy(bitmapText,graphicsRenderable),bitmapText._didTextUpdate&&(bitmapText._didTextUpdate=!1,this._updateContext(bitmapText,graphicsRenderable)),this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable,instructionSet),graphicsRenderable.context.customShader&&this._updateDistanceField(bitmapText)}updateRenderable(bitmapText){const graphicsRenderable=this._getGpuBitmapText(bitmapText);syncWithProxy(bitmapText,graphicsRenderable),this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable),graphicsRenderable.context.customShader&&this._updateDistanceField(bitmapText)}_updateContext(bitmapText,proxyGraphics){const{context}=proxyGraphics,bitmapFont=BitmapFontManager.getFont(bitmapText.text,bitmapText._style);context.clear(),"none"!==bitmapFont.distanceField.type&&(context.customShader||(context.customShader=new SdfShader(this._renderer.limits.maxBatchableTextures)));const chars=CanvasTextMetrics.P.graphemeSegmenter(bitmapText.text),style=bitmapText._style;let currentY=bitmapFont.baseLineOffset;const bitmapTextLayout=getBitmapTextLayout(chars,style,bitmapFont,!0),padding=style.padding,scale=bitmapTextLayout.scale;let tx=bitmapTextLayout.width,ty=bitmapTextLayout.height+bitmapTextLayout.offsetY;style._stroke&&(tx+=style._stroke.width/scale,ty+=style._stroke.width/scale),context.translate(-bitmapText._anchor._x*tx-padding,-bitmapText._anchor._y*ty-padding).scale(scale,scale);const tint=bitmapFont.applyFillAsTint?style._fill.color:16777215;let fontSize=bitmapFont.fontMetrics.fontSize,lineHeight=bitmapFont.lineHeight;style.lineHeight&&(fontSize=style.fontSize/scale,lineHeight=style.lineHeight/scale);let linePositionYShift=(lineHeight-fontSize)/2;linePositionYShift-bitmapFont.baseLineOffset<0&&(linePositionYShift=0);for(let i=0;i<bitmapTextLayout.lines.length;i++){const line=bitmapTextLayout.lines[i];for(let j=0;j<line.charPositions.length;j++){const char=line.chars[j],charData=bitmapFont.chars[char];if(charData?.texture){const texture=charData.texture;context.texture(texture,tint||"black",Math.round(line.charPositions[j]+charData.xOffset),Math.round(currentY+charData.yOffset+linePositionYShift),texture.orig.width,texture.orig.height)}}currentY+=lineHeight}}_getGpuBitmapText(bitmapText){return bitmapText._gpuData[this._renderer.uid]||this.initGpuText(bitmapText)}initGpuText(bitmapText){const proxyRenderable=new BitmapTextGraphics;return bitmapText._gpuData[this._renderer.uid]=proxyRenderable,this._updateContext(bitmapText,proxyRenderable),proxyRenderable}_updateDistanceField(bitmapText){const context=this._getGpuBitmapText(bitmapText).context,fontFamily=bitmapText._style.fontFamily,dynamicFont=Cache.l.get(`${fontFamily}-bitmap`),{a,b,c,d}=bitmapText.groupTransform,dx=Math.sqrt(a*a+b*b),dy=Math.sqrt(c*c+d*d),worldScale=(Math.abs(dx)+Math.abs(dy))/2,fontScale=dynamicFont.baseRenderedFontSize/bitmapText._style.fontSize,distance=worldScale*dynamicFont.distanceField.range*(1/fontScale);context.customShader.resources.localUniforms.uniforms.uDistance=distance}destroy(){this._renderer=null}}function syncWithProxy(container,proxy){proxy.groupTransform=container.groupTransform,proxy.groupColorAlpha=container.groupColorAlpha,proxy.groupColor=container.groupColor,proxy.groupBlendMode=container.groupBlendMode,proxy.globalDisplayStatus=container.globalDisplayStatus,proxy.groupTransform=container.groupTransform,proxy.localDisplayStatus=container.localDisplayStatus,proxy.groupAlpha=container.groupAlpha,proxy._roundPixels=container._roundPixels}BitmapTextPipe.extension={type:[Extensions.Ag.WebGLPipes,Extensions.Ag.WebGPUPipes,Extensions.Ag.CanvasPipes],name:"bitmapText"},Extensions.XO.add(BitmapTextPipe)},"./node_modules/pixi.js/lib/scene/text-html/init.mjs":(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{var Extensions=__webpack_require__("./node_modules/pixi.js/lib/extensions/Extensions.mjs"),Texture=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs"),updateTextBounds=__webpack_require__("./node_modules/pixi.js/lib/scene/text/utils/updateTextBounds.mjs"),BatchableSprite=__webpack_require__("./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs");class BatchableHTMLText extends BatchableSprite.K{constructor(renderer){super(),this.generatingTexture=!1,this.currentKey="--",this._renderer=renderer,renderer.runners.resolutionChange.add(this)}resolutionChange(){const text=this.renderable;text._autoResolution&&text.onViewUpdate()}destroy(){const{htmlText}=this._renderer;null===htmlText.getReferenceCount(this.currentKey)?htmlText.returnTexturePromise(this.texturePromise):htmlText.decreaseReferenceCount(this.currentKey),this._renderer.runners.resolutionChange.remove(this),this.texturePromise=null,this._renderer=null}}class HTMLTextPipe{constructor(renderer){this._renderer=renderer}validateRenderable(htmlText){const gpuText=this._getGpuText(htmlText),newKey=htmlText.styleKey;return gpuText.currentKey!==newKey}addRenderable(htmlText,instructionSet){const batchableHTMLText=this._getGpuText(htmlText);if(htmlText._didTextUpdate){const resolution=htmlText._autoResolution?this._renderer.resolution:htmlText.resolution;batchableHTMLText.currentKey===htmlText.styleKey&&htmlText.resolution===resolution||this._updateGpuText(htmlText).catch(e=>{console.error(e)}),htmlText._didTextUpdate=!1,(0,updateTextBounds.s)(batchableHTMLText,htmlText)}this._renderer.renderPipes.batch.addToBatch(batchableHTMLText,instructionSet)}updateRenderable(htmlText){const batchableHTMLText=this._getGpuText(htmlText);batchableHTMLText._batcher.updateElement(batchableHTMLText)}async _updateGpuText(htmlText){htmlText._didTextUpdate=!1;const batchableHTMLText=this._getGpuText(htmlText);if(batchableHTMLText.generatingTexture)return;const oldTexturePromise=batchableHTMLText.texturePromise;batchableHTMLText.texturePromise=null,batchableHTMLText.generatingTexture=!0,htmlText._resolution=htmlText._autoResolution?this._renderer.resolution:htmlText.resolution;let texturePromise=this._renderer.htmlText.getTexturePromise(htmlText);oldTexturePromise&&(texturePromise=texturePromise.finally(()=>{this._renderer.htmlText.decreaseReferenceCount(batchableHTMLText.currentKey),this._renderer.htmlText.returnTexturePromise(oldTexturePromise)})),batchableHTMLText.texturePromise=texturePromise,batchableHTMLText.currentKey=htmlText.styleKey,batchableHTMLText.texture=await texturePromise;const renderGroup=htmlText.renderGroup||htmlText.parentRenderGroup;renderGroup&&(renderGroup.structureDidChange=!0),batchableHTMLText.generatingTexture=!1,(0,updateTextBounds.s)(batchableHTMLText,htmlText)}_getGpuText(htmlText){return htmlText._gpuData[this._renderer.uid]||this.initGpuText(htmlText)}initGpuText(htmlText){const batchableHTMLText=new BatchableHTMLText(this._renderer);return batchableHTMLText.renderable=htmlText,batchableHTMLText.transform=htmlText.groupTransform,batchableHTMLText.texture=Texture.g.EMPTY,batchableHTMLText.bounds={minX:0,maxX:1,minY:0,maxY:0},batchableHTMLText.roundPixels=this._renderer._roundPixels|htmlText._roundPixels,htmlText._resolution=htmlText._autoResolution?this._renderer.resolution:htmlText.resolution,htmlText._gpuData[this._renderer.uid]=batchableHTMLText,batchableHTMLText}destroy(){this._renderer=null}}HTMLTextPipe.extension={type:[Extensions.Ag.WebGLPipes,Extensions.Ag.WebGPUPipes,Extensions.Ag.CanvasPipes],name:"htmlText"};var CanvasPool=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs"),TexturePool=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs"),types=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/types.mjs"),adapter=__webpack_require__("./node_modules/pixi.js/lib/environment/adapter.mjs");var warn=__webpack_require__("./node_modules/pixi.js/lib/utils/logging/warn.mjs"),PoolGroup=__webpack_require__("./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs"),getPo2TextureFromSource=__webpack_require__("./node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs");const nssvg="http://www.w3.org/2000/svg",nsxhtml="http://www.w3.org/1999/xhtml";class HTMLTextRenderData{constructor(){this.svgRoot=document.createElementNS(nssvg,"svg"),this.foreignObject=document.createElementNS(nssvg,"foreignObject"),this.domElement=document.createElementNS(nsxhtml,"div"),this.styleElement=document.createElementNS(nsxhtml,"style");const{foreignObject,svgRoot,styleElement,domElement}=this;foreignObject.setAttribute("width","10000"),foreignObject.setAttribute("height","10000"),foreignObject.style.overflow="hidden",svgRoot.appendChild(foreignObject),foreignObject.appendChild(styleElement),foreignObject.appendChild(domElement),this.image=adapter.e.get().createImage()}destroy(){this.svgRoot.remove(),this.foreignObject.remove(),this.styleElement.remove(),this.domElement.remove(),this.image.src="",this.image.remove(),this.svgRoot=null,this.foreignObject=null,this.styleElement=null,this.domElement=null,this.image=null,this.canvasAndContext=null}}var Cache=__webpack_require__("./node_modules/pixi.js/lib/assets/cache/Cache.mjs");async function loadFontCSS(style,url){const dataSrc=await async function loadFontAsBase64(url){const response=await adapter.e.get().fetch(url),blob=await response.blob(),reader=new FileReader;return await new Promise((resolve,reject)=>{reader.onloadend=()=>resolve(reader.result),reader.onerror=reject,reader.readAsDataURL(blob)})}(url);return`@font-face {\n        font-family: "${style.fontFamily}";\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n        src: url('${dataSrc}');\n    }`}const FontStylePromiseCache=new Map;let tempHTMLTextRenderData;class HTMLTextSystem{constructor(renderer){this._activeTextures={},this._renderer=renderer,this._createCanvas=renderer.type===types.W.WEBGPU}getTexture(options){return this.getTexturePromise(options)}getManagedTexture(text){const textKey=text.styleKey;if(this._activeTextures[textKey])return this._increaseReferenceCount(textKey),this._activeTextures[textKey].promise;const promise=this._buildTexturePromise(text).then(texture=>(this._activeTextures[textKey].texture=texture,texture));return this._activeTextures[textKey]={texture:null,promise,usageCount:1},promise}getReferenceCount(textKey){return this._activeTextures[textKey]?.usageCount??null}_increaseReferenceCount(textKey){this._activeTextures[textKey].usageCount++}decreaseReferenceCount(textKey){const activeTexture=this._activeTextures[textKey];activeTexture&&(activeTexture.usageCount--,0===activeTexture.usageCount&&(activeTexture.texture?this._cleanUp(activeTexture.texture):activeTexture.promise.then(texture=>{activeTexture.texture=texture,this._cleanUp(activeTexture.texture)}).catch(()=>{(0,warn.R)("HTMLTextSystem: Failed to clean texture")}),this._activeTextures[textKey]=null))}getTexturePromise(options){return this._buildTexturePromise(options)}async _buildTexturePromise(options){const{text,style,resolution,textureStyle}=options,htmlTextData=PoolGroup.Z.get(HTMLTextRenderData),fontFamilies=function extractFontFamilies(text,style){const fontFamily=style.fontFamily,fontFamilies=[],dedupe={},matches=text.match(/font-family:([^;"\s]+)/g);function addFontFamily(fontFamily2){dedupe[fontFamily2]||(fontFamilies.push(fontFamily2),dedupe[fontFamily2]=!0)}if(Array.isArray(fontFamily))for(let i=0;i<fontFamily.length;i++)addFontFamily(fontFamily[i]);else addFontFamily(fontFamily);matches&&matches.forEach(match=>{addFontFamily(match.split(":")[1].trim())});for(const i in style.tagStyles)addFontFamily(style.tagStyles[i].fontFamily);return fontFamilies}(text,style),fontCSS=await async function getFontCss(fontFamilies){const fontPromises=fontFamilies.filter(fontFamily=>Cache.l.has(`${fontFamily}-and-url`)).map(fontFamily=>{if(!FontStylePromiseCache.has(fontFamily)){const{entries}=Cache.l.get(`${fontFamily}-and-url`),promises=[];entries.forEach(entry=>{const url=entry.url,out=entry.faces.map(face=>({weight:face.weight,style:face.style}));promises.push(...out.map(style=>loadFontCSS({fontWeight:style.weight,fontStyle:style.style,fontFamily},url)))}),FontStylePromiseCache.set(fontFamily,Promise.all(promises).then(css=>css.join("\n")))}return FontStylePromiseCache.get(fontFamily)});return(await Promise.all(fontPromises)).join("\n")}(fontFamilies),measured=function measureHtmlText(text,style,fontStyleCSS,htmlTextRenderData){htmlTextRenderData||(htmlTextRenderData=tempHTMLTextRenderData||(tempHTMLTextRenderData=new HTMLTextRenderData));const{domElement,styleElement,svgRoot}=htmlTextRenderData;domElement.innerHTML=`<style>${style.cssStyle};</style><div style='padding:0'>${text}</div>`,domElement.setAttribute("style","transform-origin: top left; display: inline-block"),fontStyleCSS&&(styleElement.textContent=fontStyleCSS),document.body.appendChild(svgRoot);const contentBounds=domElement.getBoundingClientRect();svgRoot.remove();const doublePadding=2*style.padding;return{width:contentBounds.width-doublePadding,height:contentBounds.height-doublePadding}}(text,style,fontCSS,htmlTextData),width=Math.ceil(Math.ceil(Math.max(1,measured.width)+2*style.padding)*resolution),height=Math.ceil(Math.ceil(Math.max(1,measured.height)+2*style.padding)*resolution),image=htmlTextData.image;image.width=2+(0|width),image.height=2+(0|height);const svgURL=function getSVGUrl(text,style,resolution,fontCSS,htmlTextData){const{domElement,styleElement,svgRoot}=htmlTextData;domElement.innerHTML=`<style>${style.cssStyle}</style><div style='padding:0;'>${text}</div>`,domElement.setAttribute("style",`transform: scale(${resolution});transform-origin: top left; display: inline-block`),styleElement.textContent=fontCSS;const{width,height}=htmlTextData.image;return svgRoot.setAttribute("width",width.toString()),svgRoot.setAttribute("height",height.toString()),(new XMLSerializer).serializeToString(svgRoot)}(text,style,resolution,fontCSS,htmlTextData);await function loadSVGImage(image,url,delay){return new Promise(async resolve=>{delay&&await new Promise(resolve2=>setTimeout(resolve2,100)),image.onload=()=>{resolve()},image.src=`data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`,image.crossOrigin="anonymous"})}(image,svgURL,function isSafari(){const{userAgent}=adapter.e.get().getNavigator();return/^((?!chrome|android).)*safari/i.test(userAgent)}()&&fontFamilies.length>0);const resource=image;let canvasAndContext;this._createCanvas&&(canvasAndContext=function getTemporaryCanvasFromImage(image,resolution){const canvasAndContext=CanvasPool.N.getOptimalCanvasAndContext(image.width,image.height,resolution),{context}=canvasAndContext;return context.clearRect(0,0,image.width,image.height),context.drawImage(image,0,0),canvasAndContext}(image,resolution));const texture=(0,getPo2TextureFromSource.M)(canvasAndContext?canvasAndContext.canvas:resource,image.width-2,image.height-2,resolution);return textureStyle&&(texture.source.style=textureStyle),this._createCanvas&&(this._renderer.texture.initSource(texture.source),CanvasPool.N.returnCanvasAndContext(canvasAndContext)),PoolGroup.Z.return(htmlTextData),texture}returnTexturePromise(texturePromise){texturePromise.then(texture=>{this._cleanUp(texture)}).catch(()=>{(0,warn.R)("HTMLTextSystem: Failed to clean texture")})}_cleanUp(texture){TexturePool.W.returnTexture(texture,!0),texture.source.resource=null,texture.source.uploadMethodId="unknown"}destroy(){this._renderer=null;for(const key in this._activeTextures)this._activeTextures[key]&&this.returnTexturePromise(this._activeTextures[key].promise);this._activeTextures=null}}HTMLTextSystem.extension={type:[Extensions.Ag.WebGLSystem,Extensions.Ag.WebGPUSystem,Extensions.Ag.CanvasSystem],name:"htmlText"},Extensions.XO.add(HTMLTextSystem),Extensions.XO.add(HTMLTextPipe)},"./node_modules/pixi.js/lib/scene/text/TextStyle.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{x:()=>TextStyle});var eventemitter3__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/eventemitter3/index.mjs"),_color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/pixi.js/lib/color/Color.mjs"),_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/pixi.js/lib/utils/data/uid.mjs"),_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/pixi.js/lib/utils/logging/deprecation.mjs"),_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__("./node_modules/pixi.js/lib/utils/logging/warn.mjs"),_graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__("./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs"),_graphics_shared_fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__("./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs"),_graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_7__=__webpack_require__("./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs"),_graphics_shared_utils_convertFillInputToFillStyle_mjs__WEBPACK_IMPORTED_MODULE_8__=__webpack_require__("./node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs");const _TextStyle=class _TextStyle extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__.A{constructor(style={}){super(),this.uid=(0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_2__.L)("textStyle"),this._tick=0,function convertV7Tov8Style(style){const oldStyle=style;if("boolean"==typeof oldStyle.dropShadow&&oldStyle.dropShadow){const defaults=TextStyle.defaultDropShadow;style.dropShadow={alpha:oldStyle.dropShadowAlpha??defaults.alpha,angle:oldStyle.dropShadowAngle??defaults.angle,blur:oldStyle.dropShadowBlur??defaults.blur,color:oldStyle.dropShadowColor??defaults.color,distance:oldStyle.dropShadowDistance??defaults.distance}}if(void 0!==oldStyle.strokeThickness){(0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_3__.t6)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_3__.lj,"strokeThickness is now a part of stroke");const color=oldStyle.stroke;let obj={};if(_color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__.Q.isColorLike(color))obj.color=color;else if(color instanceof _graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_5__._||color instanceof _graphics_shared_fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_6__.m)obj.fill=color;else{if(!Object.hasOwnProperty.call(color,"color")&&!Object.hasOwnProperty.call(color,"fill"))throw new Error("Invalid stroke value.");obj=color}style.stroke={...obj,width:oldStyle.strokeThickness}}if(Array.isArray(oldStyle.fillGradientStops)){if((0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_3__.t6)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_3__.lj,"gradient fill is now a fill pattern: `new FillGradient(...)`"),!Array.isArray(oldStyle.fill)||0===oldStyle.fill.length)throw new Error("Invalid fill value. Expected an array of colors for gradient fill.");oldStyle.fill.length!==oldStyle.fillGradientStops.length&&(0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_4__.R)("The number of fill colors must match the number of fill gradient stops.");const gradientFill=new _graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_5__._({start:{x:0,y:0},end:{x:0,y:1},textureSpace:"local"}),fillGradientStops=oldStyle.fillGradientStops.slice(),fills=oldStyle.fill.map(color=>_color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__.Q.shared.setValue(color).toNumber());fillGradientStops.forEach((stop,index)=>{gradientFill.addColorStop(stop,fills[index])}),style.fill={fill:gradientFill}}}(style);const fullStyle={..._TextStyle.defaultTextStyle,...style};for(const key in fullStyle){this[key]=fullStyle[key]}this.update(),this._tick=0}get align(){return this._align}set align(value){this._align!==value&&(this._align=value,this.update())}get breakWords(){return this._breakWords}set breakWords(value){this._breakWords!==value&&(this._breakWords=value,this.update())}get dropShadow(){return this._dropShadow}set dropShadow(value){this._dropShadow!==value&&(this._dropShadow=null!==value&&"object"==typeof value?this._createProxy({..._TextStyle.defaultDropShadow,...value}):value?this._createProxy({..._TextStyle.defaultDropShadow}):null,this.update())}get fontFamily(){return this._fontFamily}set fontFamily(value){this._fontFamily!==value&&(this._fontFamily=value,this.update())}get fontSize(){return this._fontSize}set fontSize(value){this._fontSize!==value&&(this._fontSize="string"==typeof value?parseInt(value,10):value,this.update())}get fontStyle(){return this._fontStyle}set fontStyle(value){this._fontStyle!==value&&(this._fontStyle=value.toLowerCase(),this.update())}get fontVariant(){return this._fontVariant}set fontVariant(value){this._fontVariant!==value&&(this._fontVariant=value,this.update())}get fontWeight(){return this._fontWeight}set fontWeight(value){this._fontWeight!==value&&(this._fontWeight=value,this.update())}get leading(){return this._leading}set leading(value){this._leading!==value&&(this._leading=value,this.update())}get letterSpacing(){return this._letterSpacing}set letterSpacing(value){this._letterSpacing!==value&&(this._letterSpacing=value,this.update())}get lineHeight(){return this._lineHeight}set lineHeight(value){this._lineHeight!==value&&(this._lineHeight=value,this.update())}get padding(){return this._padding}set padding(value){this._padding!==value&&(this._padding=value,this.update())}get filters(){return this._filters}set filters(value){this._filters!==value&&(this._filters=Object.freeze(value),this.update())}get trim(){return this._trim}set trim(value){this._trim!==value&&(this._trim=value,this.update())}get textBaseline(){return this._textBaseline}set textBaseline(value){this._textBaseline!==value&&(this._textBaseline=value,this.update())}get whiteSpace(){return this._whiteSpace}set whiteSpace(value){this._whiteSpace!==value&&(this._whiteSpace=value,this.update())}get wordWrap(){return this._wordWrap}set wordWrap(value){this._wordWrap!==value&&(this._wordWrap=value,this.update())}get wordWrapWidth(){return this._wordWrapWidth}set wordWrapWidth(value){this._wordWrapWidth!==value&&(this._wordWrapWidth=value,this.update())}get fill(){return this._originalFill}set fill(value){value!==this._originalFill&&(this._originalFill=value,this._isFillStyle(value)&&(this._originalFill=this._createProxy({..._graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_7__.T.defaultFillStyle,...value},()=>{this._fill=(0,_graphics_shared_utils_convertFillInputToFillStyle_mjs__WEBPACK_IMPORTED_MODULE_8__.w)({...this._originalFill},_graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_7__.T.defaultFillStyle)})),this._fill=(0,_graphics_shared_utils_convertFillInputToFillStyle_mjs__WEBPACK_IMPORTED_MODULE_8__.w)(0===value?"black":value,_graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_7__.T.defaultFillStyle),this.update())}get stroke(){return this._originalStroke}set stroke(value){value!==this._originalStroke&&(this._originalStroke=value,this._isFillStyle(value)&&(this._originalStroke=this._createProxy({..._graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_7__.T.defaultStrokeStyle,...value},()=>{this._stroke=(0,_graphics_shared_utils_convertFillInputToFillStyle_mjs__WEBPACK_IMPORTED_MODULE_8__.T)({...this._originalStroke},_graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_7__.T.defaultStrokeStyle)})),this._stroke=(0,_graphics_shared_utils_convertFillInputToFillStyle_mjs__WEBPACK_IMPORTED_MODULE_8__.T)(value,_graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_7__.T.defaultStrokeStyle),this.update())}update(){this._tick++,this.emit("update",this)}reset(){const defaultStyle=_TextStyle.defaultTextStyle;for(const key in defaultStyle)this[key]=defaultStyle[key]}get styleKey(){return`${this.uid}-${this._tick}`}clone(){return new _TextStyle({align:this.align,breakWords:this.breakWords,dropShadow:this._dropShadow?{...this._dropShadow}:null,fill:this._fill,fontFamily:this.fontFamily,fontSize:this.fontSize,fontStyle:this.fontStyle,fontVariant:this.fontVariant,fontWeight:this.fontWeight,leading:this.leading,letterSpacing:this.letterSpacing,lineHeight:this.lineHeight,padding:this.padding,stroke:this._stroke,textBaseline:this.textBaseline,whiteSpace:this.whiteSpace,wordWrap:this.wordWrap,wordWrapWidth:this.wordWrapWidth,filters:this._filters?[...this._filters]:void 0})}_getFinalPadding(){let filterPadding=0;if(this._filters)for(let i=0;i<this._filters.length;i++)filterPadding+=this._filters[i].padding;return Math.max(this._padding,filterPadding)}destroy(options=!1){this.removeAllListeners();if("boolean"==typeof options?options:options?.texture){const destroyTextureSource="boolean"==typeof options?options:options?.textureSource;this._fill?.texture&&this._fill.texture.destroy(destroyTextureSource),this._originalFill?.texture&&this._originalFill.texture.destroy(destroyTextureSource),this._stroke?.texture&&this._stroke.texture.destroy(destroyTextureSource),this._originalStroke?.texture&&this._originalStroke.texture.destroy(destroyTextureSource)}this._fill=null,this._stroke=null,this.dropShadow=null,this._originalStroke=null,this._originalFill=null}_createProxy(value,cb){return new Proxy(value,{set:(target,property,newValue)=>(target[property]===newValue||(target[property]=newValue,cb?.(property,newValue),this.update()),!0)})}_isFillStyle(value){return null!==(value??null)&&!(_color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__.Q.isColorLike(value)||value instanceof _graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_5__._||value instanceof _graphics_shared_fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_6__.m)}};_TextStyle.defaultDropShadow={alpha:1,angle:Math.PI/6,blur:0,color:"black",distance:5},_TextStyle.defaultTextStyle={align:"left",breakWords:!1,dropShadow:null,fill:"black",fontFamily:"Arial",fontSize:26,fontStyle:"normal",fontVariant:"normal",fontWeight:"normal",leading:0,letterSpacing:0,lineHeight:0,padding:0,stroke:null,textBaseline:"alphabetic",trim:!1,whiteSpace:"pre",wordWrap:!1,wordWrapWidth:100};let TextStyle=_TextStyle},"./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{P:()=>CanvasTextMetrics});var tiny_lru__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/tiny-lru/dist/tiny-lru.js"),_environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/pixi.js/lib/environment/adapter.mjs"),_utils_fontStringFromTextStyle_mjs__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs");const contextSettings={willReadFrequently:!0},_CanvasTextMetrics=class _CanvasTextMetrics{static get experimentalLetterSpacingSupported(){let result=_CanvasTextMetrics._experimentalLetterSpacingSupported;if(void 0===result){const proto=_environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_1__.e.get().getCanvasRenderingContext2D().prototype;result=_CanvasTextMetrics._experimentalLetterSpacingSupported="letterSpacing"in proto||"textLetterSpacing"in proto}return result}constructor(text,style,width,height,lines,lineWidths,lineHeight,maxLineWidth,fontProperties){this.text=text,this.style=style,this.width=width,this.height=height,this.lines=lines,this.lineWidths=lineWidths,this.lineHeight=lineHeight,this.maxLineWidth=maxLineWidth,this.fontProperties=fontProperties}static measureText(text=" ",style,canvas=_CanvasTextMetrics._canvas,wordWrap=style.wordWrap){const textKey=`${text}-${style.styleKey}-wordWrap-${wordWrap}`;if(_CanvasTextMetrics._measurementCache.has(textKey))return _CanvasTextMetrics._measurementCache.get(textKey);const font=(0,_utils_fontStringFromTextStyle_mjs__WEBPACK_IMPORTED_MODULE_2__.Z)(style),fontProperties=_CanvasTextMetrics.measureFont(font);0===fontProperties.fontSize&&(fontProperties.fontSize=style.fontSize,fontProperties.ascent=style.fontSize);const context=_CanvasTextMetrics.__context;context.font=font;const lines=(wordWrap?_CanvasTextMetrics._wordWrap(text,style,canvas):text).split(/(?:\r\n|\r|\n)/),lineWidths=new Array(lines.length);let maxLineWidth=0;for(let i=0;i<lines.length;i++){const lineWidth=_CanvasTextMetrics._measureText(lines[i],style.letterSpacing,context);lineWidths[i]=lineWidth,maxLineWidth=Math.max(maxLineWidth,lineWidth)}const strokeWidth=style._stroke?.width||0;let width=maxLineWidth+strokeWidth;style.dropShadow&&(width+=style.dropShadow.distance);const lineHeight=style.lineHeight||fontProperties.fontSize;let height=Math.max(lineHeight,fontProperties.fontSize+strokeWidth)+(lines.length-1)*(lineHeight+style.leading);style.dropShadow&&(height+=style.dropShadow.distance);const measurements=new _CanvasTextMetrics(text,style,width,height,lines,lineWidths,lineHeight+style.leading,maxLineWidth,fontProperties);return _CanvasTextMetrics._measurementCache.set(textKey,measurements),measurements}static _measureText(text,letterSpacing,context){let useExperimentalLetterSpacing=!1;_CanvasTextMetrics.experimentalLetterSpacingSupported&&(_CanvasTextMetrics.experimentalLetterSpacing?(context.letterSpacing=`${letterSpacing}px`,context.textLetterSpacing=`${letterSpacing}px`,useExperimentalLetterSpacing=!0):(context.letterSpacing="0px",context.textLetterSpacing="0px"));const metrics=context.measureText(text);let metricWidth=metrics.width;const actualBoundingBoxLeft=-metrics.actualBoundingBoxLeft;let boundsWidth=metrics.actualBoundingBoxRight-actualBoundingBoxLeft;if(metricWidth>0)if(useExperimentalLetterSpacing)metricWidth-=letterSpacing,boundsWidth-=letterSpacing;else{const val=(_CanvasTextMetrics.graphemeSegmenter(text).length-1)*letterSpacing;metricWidth+=val,boundsWidth+=val}return Math.max(metricWidth,boundsWidth)}static _wordWrap(text,style,canvas=_CanvasTextMetrics._canvas){const context=canvas.getContext("2d",contextSettings);let width=0,line="",lines="";const cache=Object.create(null),{letterSpacing,whiteSpace}=style,collapseSpaces=_CanvasTextMetrics._collapseSpaces(whiteSpace),collapseNewlines=_CanvasTextMetrics._collapseNewlines(whiteSpace);let canPrependSpaces=!collapseSpaces;const wordWrapWidth=style.wordWrapWidth+letterSpacing,tokens=_CanvasTextMetrics._tokenize(text);for(let i=0;i<tokens.length;i++){let token=tokens[i];if(_CanvasTextMetrics._isNewline(token)){if(!collapseNewlines){lines+=_CanvasTextMetrics._addLine(line),canPrependSpaces=!collapseSpaces,line="",width=0;continue}token=" "}if(collapseSpaces){const currIsBreakingSpace=_CanvasTextMetrics.isBreakingSpace(token),lastIsBreakingSpace=_CanvasTextMetrics.isBreakingSpace(line[line.length-1]);if(currIsBreakingSpace&&lastIsBreakingSpace)continue}const tokenWidth=_CanvasTextMetrics._getFromCache(token,letterSpacing,cache,context);if(tokenWidth>wordWrapWidth)if(""!==line&&(lines+=_CanvasTextMetrics._addLine(line),line="",width=0),_CanvasTextMetrics.canBreakWords(token,style.breakWords)){const characters=_CanvasTextMetrics.wordWrapSplit(token);for(let j=0;j<characters.length;j++){let char=characters[j],lastChar=char,k=1;for(;characters[j+k];){const nextChar=characters[j+k];if(_CanvasTextMetrics.canBreakChars(lastChar,nextChar,token,j,style.breakWords))break;char+=nextChar,lastChar=nextChar,k++}j+=k-1;const characterWidth=_CanvasTextMetrics._getFromCache(char,letterSpacing,cache,context);characterWidth+width>wordWrapWidth&&(lines+=_CanvasTextMetrics._addLine(line),canPrependSpaces=!1,line="",width=0),line+=char,width+=characterWidth}}else{line.length>0&&(lines+=_CanvasTextMetrics._addLine(line),line="",width=0);const isLastToken=i===tokens.length-1;lines+=_CanvasTextMetrics._addLine(token,!isLastToken),canPrependSpaces=!1,line="",width=0}else tokenWidth+width>wordWrapWidth&&(canPrependSpaces=!1,lines+=_CanvasTextMetrics._addLine(line),line="",width=0),(line.length>0||!_CanvasTextMetrics.isBreakingSpace(token)||canPrependSpaces)&&(line+=token,width+=tokenWidth)}return lines+=_CanvasTextMetrics._addLine(line,!1),lines}static _addLine(line,newLine=!0){return line=_CanvasTextMetrics._trimRight(line),line=newLine?`${line}\n`:line}static _getFromCache(key,letterSpacing,cache,context){let width=cache[key];return"number"!=typeof width&&(width=_CanvasTextMetrics._measureText(key,letterSpacing,context)+letterSpacing,cache[key]=width),width}static _collapseSpaces(whiteSpace){return"normal"===whiteSpace||"pre-line"===whiteSpace}static _collapseNewlines(whiteSpace){return"normal"===whiteSpace}static _trimRight(text){if("string"!=typeof text)return"";for(let i=text.length-1;i>=0;i--){const char=text[i];if(!_CanvasTextMetrics.isBreakingSpace(char))break;text=text.slice(0,-1)}return text}static _isNewline(char){return"string"==typeof char&&_CanvasTextMetrics._newlines.includes(char.charCodeAt(0))}static isBreakingSpace(char,_nextChar){return"string"==typeof char&&_CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0))}static _tokenize(text){const tokens=[];let token="";if("string"!=typeof text)return tokens;for(let i=0;i<text.length;i++){const char=text[i],nextChar=text[i+1];_CanvasTextMetrics.isBreakingSpace(char,nextChar)||_CanvasTextMetrics._isNewline(char)?(""!==token&&(tokens.push(token),token=""),"\r"===char&&"\n"===nextChar?(tokens.push("\r\n"),i++):tokens.push(char)):token+=char}return""!==token&&tokens.push(token),tokens}static canBreakWords(_token,breakWords){return breakWords}static canBreakChars(_char,_nextChar,_token,_index,_breakWords){return!0}static wordWrapSplit(token){return _CanvasTextMetrics.graphemeSegmenter(token)}static measureFont(font){if(_CanvasTextMetrics._fonts[font])return _CanvasTextMetrics._fonts[font];const context=_CanvasTextMetrics._context;context.font=font;const metrics=context.measureText(_CanvasTextMetrics.METRICS_STRING+_CanvasTextMetrics.BASELINE_SYMBOL),properties={ascent:metrics.actualBoundingBoxAscent,descent:metrics.actualBoundingBoxDescent,fontSize:metrics.actualBoundingBoxAscent+metrics.actualBoundingBoxDescent};return _CanvasTextMetrics._fonts[font]=properties,properties}static clearMetrics(font=""){font?delete _CanvasTextMetrics._fonts[font]:_CanvasTextMetrics._fonts={}}static get _canvas(){if(!_CanvasTextMetrics.__canvas){let canvas;try{const c=new OffscreenCanvas(0,0),context=c.getContext("2d",contextSettings);if(context?.measureText)return _CanvasTextMetrics.__canvas=c,c;canvas=_environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_1__.e.get().createCanvas()}catch(_cx){canvas=_environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_1__.e.get().createCanvas()}canvas.width=canvas.height=10,_CanvasTextMetrics.__canvas=canvas}return _CanvasTextMetrics.__canvas}static get _context(){return _CanvasTextMetrics.__context||(_CanvasTextMetrics.__context=_CanvasTextMetrics._canvas.getContext("2d",contextSettings)),_CanvasTextMetrics.__context}};_CanvasTextMetrics.METRICS_STRING="|q",_CanvasTextMetrics.BASELINE_SYMBOL="M",_CanvasTextMetrics.BASELINE_MULTIPLIER=1.4,_CanvasTextMetrics.HEIGHT_MULTIPLIER=2,_CanvasTextMetrics.graphemeSegmenter=(()=>{if("function"==typeof Intl?.Segmenter){const segmenter=new Intl.Segmenter;return s=>{const segments=segmenter.segment(s),result=[];let i=0;for(const segment of segments)result[i++]=segment.segment;return result}}return s=>[...s]})(),_CanvasTextMetrics.experimentalLetterSpacing=!1,_CanvasTextMetrics._fonts={},_CanvasTextMetrics._newlines=[10,13],_CanvasTextMetrics._breakingSpaces=[9,32,8192,8193,8194,8195,8196,8197,8198,8200,8201,8202,8287,12288],_CanvasTextMetrics._measurementCache=(0,tiny_lru__WEBPACK_IMPORTED_MODULE_0__.g)(1e3);let CanvasTextMetrics=_CanvasTextMetrics},"./node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Z:()=>fontStringFromTextStyle});const genericFontFamilies=["serif","sans-serif","monospace","cursive","fantasy","system-ui"];function fontStringFromTextStyle(style){const fontSizeString="number"==typeof style.fontSize?`${style.fontSize}px`:style.fontSize;let fontFamilies=style.fontFamily;Array.isArray(style.fontFamily)||(fontFamilies=style.fontFamily.split(","));for(let i=fontFamilies.length-1;i>=0;i--){let fontFamily=fontFamilies[i].trim();/([\"\'])[^\'\"]+\1/.test(fontFamily)||genericFontFamilies.includes(fontFamily)||(fontFamily=`"${fontFamily}"`),fontFamilies[i]=fontFamily}return`${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`}},"./node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{r:()=>getCanvasFillStyle});var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/pixi.js/lib/color/Color.mjs"),_maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs"),_rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs"),_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/pixi.js/lib/utils/logging/warn.mjs"),_graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__("./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs"),_graphics_shared_fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__("./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs");const PRECISION=1e5;function getCanvasFillStyle(fillStyle,context,textMetrics,padding=0){if(fillStyle.texture===_rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_2__.g.WHITE&&!fillStyle.fill)return _color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__.Q.shared.setValue(fillStyle.color).setAlpha(fillStyle.alpha??1).toHexa();if(!fillStyle.fill){const pattern=context.createPattern(fillStyle.texture.source.resource,"repeat"),tempMatrix=fillStyle.matrix.copyTo(_maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__.u.shared);return tempMatrix.scale(fillStyle.texture.frame.width,fillStyle.texture.frame.height),pattern.setTransform(tempMatrix),pattern}if(fillStyle.fill instanceof _graphics_shared_fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_5__.m){const fillPattern=fillStyle.fill,pattern=context.createPattern(fillPattern.texture.source.resource,"repeat"),tempMatrix=fillPattern.transform.copyTo(_maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__.u.shared);return tempMatrix.scale(fillPattern.texture.frame.width,fillPattern.texture.frame.height),pattern.setTransform(tempMatrix),pattern}if(fillStyle.fill instanceof _graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_4__._){const fillGradient=fillStyle.fill,isLinear="linear"===fillGradient.type,isLocal="local"===fillGradient.textureSpace;let gradient,width=1,height=1;isLocal&&textMetrics&&(width=textMetrics.width+padding,height=textMetrics.height+padding);let isNearlyVertical=!1;if(isLinear){const{start,end}=fillGradient;gradient=context.createLinearGradient(start.x*width,start.y*height,end.x*width,end.y*height),isNearlyVertical=Math.abs(end.x-start.x)<Math.abs(.1*(end.y-start.y))}else{const{center,innerRadius,outerCenter,outerRadius}=fillGradient;gradient=context.createRadialGradient(center.x*width,center.y*height,innerRadius*width,outerCenter.x*width,outerCenter.y*height,outerRadius*width)}if(isNearlyVertical&&isLocal&&textMetrics){const ratio=textMetrics.lineHeight/height;for(let i=0;i<textMetrics.lines.length;i++){const start=(i*textMetrics.lineHeight+padding/2)/height;fillGradient.colorStops.forEach(stop=>{const globalStop=start+stop.offset*ratio;gradient.addColorStop(Math.floor(globalStop*PRECISION)/PRECISION,_color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__.Q.shared.setValue(stop.color).toHex())})}}else fillGradient.colorStops.forEach(stop=>{gradient.addColorStop(stop.offset,_color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__.Q.shared.setValue(stop.color).toHex())});return gradient}return(0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_3__.R)("FillStyle not recognised",fillStyle),"red"}},"./node_modules/pixi.js/lib/scene/text/init.mjs":(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{var Extensions=__webpack_require__("./node_modules/pixi.js/lib/extensions/Extensions.mjs"),updateTextBounds=__webpack_require__("./node_modules/pixi.js/lib/scene/text/utils/updateTextBounds.mjs"),BatchableSprite=__webpack_require__("./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs");class BatchableText extends BatchableSprite.K{constructor(renderer){super(),this._renderer=renderer,renderer.runners.resolutionChange.add(this)}resolutionChange(){const text=this.renderable;text._autoResolution&&text.onViewUpdate()}destroy(){const{canvasText}=this._renderer;canvasText.getReferenceCount(this.currentKey)>0?canvasText.decreaseReferenceCount(this.currentKey):this.texture&&canvasText.returnTexture(this.texture),this._renderer.runners.resolutionChange.remove(this),this._renderer=null}}class CanvasTextPipe{constructor(renderer){this._renderer=renderer}validateRenderable(text){const gpuText=this._getGpuText(text),newKey=text.styleKey;return gpuText.currentKey!==newKey||text._didTextUpdate}addRenderable(text,instructionSet){const batchableText=this._getGpuText(text);if(text._didTextUpdate){const resolution=text._autoResolution?this._renderer.resolution:text.resolution;batchableText.currentKey===text.styleKey&&text.resolution===resolution||this._updateGpuText(text),text._didTextUpdate=!1,(0,updateTextBounds.s)(batchableText,text)}this._renderer.renderPipes.batch.addToBatch(batchableText,instructionSet)}updateRenderable(text){const batchableText=this._getGpuText(text);batchableText._batcher.updateElement(batchableText)}_updateGpuText(text){const batchableText=this._getGpuText(text);batchableText.texture&&this._renderer.canvasText.decreaseReferenceCount(batchableText.currentKey),text._resolution=text._autoResolution?this._renderer.resolution:text.resolution,batchableText.texture=this._renderer.canvasText.getManagedTexture(text),batchableText.currentKey=text.styleKey}_getGpuText(text){return text._gpuData[this._renderer.uid]||this.initGpuText(text)}initGpuText(text){const batchableText=new BatchableText(this._renderer);return batchableText.currentKey="--",batchableText.renderable=text,batchableText.transform=text.groupTransform,batchableText.bounds={minX:0,maxX:1,minY:0,maxY:0},batchableText.roundPixels=this._renderer._roundPixels|text._roundPixels,text._gpuData[this._renderer.uid]=batchableText,batchableText}destroy(){this._renderer=null}}CanvasTextPipe.extension={type:[Extensions.Ag.WebGLPipes,Extensions.Ag.WebGPUPipes,Extensions.Ag.CanvasPipes],name:"text"};var TexturePool=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs"),TextureStyle=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs"),deprecation=__webpack_require__("./node_modules/pixi.js/lib/utils/logging/deprecation.mjs"),TextStyle=__webpack_require__("./node_modules/pixi.js/lib/scene/text/TextStyle.mjs"),getPo2TextureFromSource=__webpack_require__("./node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs"),Color=__webpack_require__("./node_modules/pixi.js/lib/color/Color.mjs"),Rectangle=__webpack_require__("./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs"),CanvasPool=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs"),adapter=__webpack_require__("./node_modules/pixi.js/lib/environment/adapter.mjs"),pow2=__webpack_require__("./node_modules/pixi.js/lib/maths/misc/pow2.mjs");let _internalCanvas=null,_internalContext=null;function checkRow(data,width,y){for(let x=0,index=4*y*width;x<width;++x,index+=4)if(0!==data[index+3])return!1;return!0}function checkColumn(data,width,x,top,bottom){const stride=4*width;for(let y=top,index=top*stride+4*x;y<=bottom;++y,index+=stride)if(0!==data[index+3])return!1;return!0}function getCanvasBoundingBox(...args){let options=args[0];options.canvas||(options={canvas:args[0],resolution:args[1]});const{canvas}=options,resolution=Math.min(options.resolution??1,1),width=options.width??canvas.width,height=options.height??canvas.height;let output=options.output;if(function ensureInternalCanvas(width,height){_internalCanvas||(_internalCanvas=adapter.e.get().createCanvas(256,128),_internalContext=_internalCanvas.getContext("2d",{willReadFrequently:!0}),_internalContext.globalCompositeOperation="copy",_internalContext.globalAlpha=1),(_internalCanvas.width<width||_internalCanvas.height<height)&&(_internalCanvas.width=(0,pow2.U5)(width),_internalCanvas.height=(0,pow2.U5)(height))}(width,height),!_internalContext)throw new TypeError("Failed to get canvas 2D context");_internalContext.drawImage(canvas,0,0,width,height,0,0,width*resolution,height*resolution);const data=_internalContext.getImageData(0,0,width,height).data;let left=0,top=0,right=width-1,bottom=height-1;for(;top<height&&checkRow(data,width,top);)++top;if(top===height)return Rectangle.M.EMPTY;for(;checkRow(data,width,bottom);)--bottom;for(;checkColumn(data,width,left,top,bottom);)++left;for(;checkColumn(data,width,right,top,bottom);)--right;return++right,++bottom,_internalContext.globalCompositeOperation="source-over",_internalContext.strokeRect(left,top,right-left,bottom-top),_internalContext.globalCompositeOperation="copy",output??(output=new Rectangle.M),output.set(left/resolution,top/resolution,(right-left)/resolution,(bottom-top)/resolution),output}var CanvasTextMetrics=__webpack_require__("./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs"),fontStringFromTextStyle=__webpack_require__("./node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs"),getCanvasFillStyle=__webpack_require__("./node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs");const tempRect=new Rectangle.M;const CanvasTextGenerator=new class CanvasTextGeneratorClass{getCanvasAndContext(options){const{text,style,resolution=1}=options,padding=style._getFinalPadding(),measured=CanvasTextMetrics.P.measureText(text||" ",style),width=Math.ceil(Math.ceil(Math.max(1,measured.width)+2*padding)*resolution),height=Math.ceil(Math.ceil(Math.max(1,measured.height)+2*padding)*resolution),canvasAndContext=CanvasPool.N.getOptimalCanvasAndContext(width,height);this._renderTextToCanvas(text,style,padding,resolution,canvasAndContext);return{canvasAndContext,frame:style.trim?getCanvasBoundingBox({canvas:canvasAndContext.canvas,width,height,resolution:1,output:tempRect}):tempRect.set(0,0,width,height)}}returnCanvasAndContext(canvasAndContext){CanvasPool.N.returnCanvasAndContext(canvasAndContext)}_renderTextToCanvas(text,style,padding,resolution,canvasAndContext){const{canvas,context}=canvasAndContext,font=(0,fontStringFromTextStyle.Z)(style),measured=CanvasTextMetrics.P.measureText(text||" ",style),lines=measured.lines,lineHeight=measured.lineHeight,lineWidths=measured.lineWidths,maxLineWidth=measured.maxLineWidth,fontProperties=measured.fontProperties,height=canvas.height;if(context.resetTransform(),context.scale(resolution,resolution),context.textBaseline=style.textBaseline,style._stroke?.width){const strokeStyle=style._stroke;context.lineWidth=strokeStyle.width,context.miterLimit=strokeStyle.miterLimit,context.lineJoin=strokeStyle.join,context.lineCap=strokeStyle.cap}let linePositionX,linePositionY;context.font=font;const passesCount=style.dropShadow?2:1;for(let i=0;i<passesCount;++i){const isShadowPass=style.dropShadow&&0===i,dsOffsetText=isShadowPass?Math.ceil(Math.max(1,height)+2*padding):0,dsOffsetShadow=dsOffsetText*resolution;if(isShadowPass){context.fillStyle="black",context.strokeStyle="black";const shadowOptions=style.dropShadow,dropShadowColor=shadowOptions.color,dropShadowAlpha=shadowOptions.alpha;context.shadowColor=Color.Q.shared.setValue(dropShadowColor).setAlpha(dropShadowAlpha).toRgbaString();const dropShadowBlur=shadowOptions.blur*resolution,dropShadowDistance=shadowOptions.distance*resolution;context.shadowBlur=dropShadowBlur,context.shadowOffsetX=Math.cos(shadowOptions.angle)*dropShadowDistance,context.shadowOffsetY=Math.sin(shadowOptions.angle)*dropShadowDistance+dsOffsetShadow}else{if(context.fillStyle=style._fill?(0,getCanvasFillStyle.r)(style._fill,context,measured,2*padding):null,style._stroke?.width){const strokePadding=.5*style._stroke.width+2*padding;context.strokeStyle=(0,getCanvasFillStyle.r)(style._stroke,context,measured,strokePadding)}context.shadowColor="black"}let linePositionYShift=(lineHeight-fontProperties.fontSize)/2;lineHeight-fontProperties.fontSize<0&&(linePositionYShift=0);const strokeWidth=style._stroke?.width??0;for(let i2=0;i2<lines.length;i2++)linePositionX=strokeWidth/2,linePositionY=strokeWidth/2+i2*lineHeight+fontProperties.ascent+linePositionYShift,"right"===style.align?linePositionX+=maxLineWidth-lineWidths[i2]:"center"===style.align&&(linePositionX+=(maxLineWidth-lineWidths[i2])/2),style._stroke?.width&&this._drawLetterSpacing(lines[i2],style,canvasAndContext,linePositionX+padding,linePositionY+padding-dsOffsetText,!0),void 0!==style._fill&&this._drawLetterSpacing(lines[i2],style,canvasAndContext,linePositionX+padding,linePositionY+padding-dsOffsetText)}}_drawLetterSpacing(text,style,canvasAndContext,x,y,isStroke=!1){const{context}=canvasAndContext,letterSpacing=style.letterSpacing;let useExperimentalLetterSpacing=!1;if(CanvasTextMetrics.P.experimentalLetterSpacingSupported&&(CanvasTextMetrics.P.experimentalLetterSpacing?(context.letterSpacing=`${letterSpacing}px`,context.textLetterSpacing=`${letterSpacing}px`,useExperimentalLetterSpacing=!0):(context.letterSpacing="0px",context.textLetterSpacing="0px")),0===letterSpacing||useExperimentalLetterSpacing)return void(isStroke?context.strokeText(text,x,y):context.fillText(text,x,y));let currentPosition=x;const stringArray=CanvasTextMetrics.P.graphemeSegmenter(text);let previousWidth=context.measureText(text).width,currentWidth=0;for(let i=0;i<stringArray.length;++i){const currentChar=stringArray[i];isStroke?context.strokeText(currentChar,currentPosition,y):context.fillText(currentChar,currentPosition,y);let textStr="";for(let j=i+1;j<stringArray.length;++j)textStr+=stringArray[j];currentWidth=context.measureText(textStr).width,currentPosition+=previousWidth-currentWidth+letterSpacing,previousWidth=currentWidth}}};class CanvasTextSystem{constructor(_renderer){this._activeTextures={},this._renderer=_renderer}getTexture(options,_resolution,_style,_textKey){"string"==typeof options&&((0,deprecation.t6)("8.0.0","CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments"),options={text:options,style:_style,resolution:_resolution}),options.style instanceof TextStyle.x||(options.style=new TextStyle.x(options.style)),options.textureStyle instanceof TextureStyle.n||(options.textureStyle=new TextureStyle.n(options.textureStyle)),"string"!=typeof options.text&&(options.text=options.text.toString());const{text,style,textureStyle}=options,resolution=options.resolution??this._renderer.resolution,{frame,canvasAndContext}=CanvasTextGenerator.getCanvasAndContext({text,style,resolution}),texture=(0,getPo2TextureFromSource.M)(canvasAndContext.canvas,frame.width,frame.height,resolution);if(textureStyle&&(texture.source.style=textureStyle),style.trim&&(frame.pad(style.padding),texture.frame.copyFrom(frame),texture.frame.scale(1/resolution),texture.updateUvs()),style.filters){const filteredTexture=this._applyFilters(texture,style.filters);return this.returnTexture(texture),CanvasTextGenerator.returnCanvasAndContext(canvasAndContext),filteredTexture}return this._renderer.texture.initSource(texture._source),CanvasTextGenerator.returnCanvasAndContext(canvasAndContext),texture}returnTexture(texture){const source=texture.source;source.resource=null,source.uploadMethodId="unknown",source.alphaMode="no-premultiply-alpha",TexturePool.W.returnTexture(texture,!0)}renderTextToCanvas(){(0,deprecation.t6)("8.10.0","CanvasTextSystem.renderTextToCanvas: no longer supported, use CanvasTextSystem.getTexture instead")}getManagedTexture(text){text._resolution=text._autoResolution?this._renderer.resolution:text.resolution;const textKey=text.styleKey;if(this._activeTextures[textKey])return this._increaseReferenceCount(textKey),this._activeTextures[textKey].texture;const texture=this.getTexture({text:text.text,style:text.style,resolution:text._resolution,textureStyle:text.textureStyle});return this._activeTextures[textKey]={texture,usageCount:1},texture}decreaseReferenceCount(textKey){const activeTexture=this._activeTextures[textKey];activeTexture.usageCount--,0===activeTexture.usageCount&&(this.returnTexture(activeTexture.texture),this._activeTextures[textKey]=null)}getReferenceCount(textKey){return this._activeTextures[textKey]?.usageCount??0}_increaseReferenceCount(textKey){this._activeTextures[textKey].usageCount++}_applyFilters(texture,filters){const currentRenderTarget=this._renderer.renderTarget.renderTarget,resultTexture=this._renderer.filter.generateFilteredTexture({texture,filters});return this._renderer.renderTarget.bind(currentRenderTarget,!1),resultTexture}destroy(){this._renderer=null;for(const key in this._activeTextures)this._activeTextures[key]&&this.returnTexture(this._activeTextures[key].texture);this._activeTextures=null}}CanvasTextSystem.extension={type:[Extensions.Ag.WebGLSystem,Extensions.Ag.WebGPUSystem,Extensions.Ag.CanvasSystem],name:"canvasText"},Extensions.XO.add(CanvasTextSystem),Extensions.XO.add(CanvasTextPipe)},"./node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{M:()=>getPo2TextureFromSource});var _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs");const tempBounds=new(__webpack_require__("./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs").c);function getPo2TextureFromSource(image,width,height,resolution){const bounds=tempBounds;bounds.minX=0,bounds.minY=0,bounds.maxX=image.width/resolution|0,bounds.maxY=image.height/resolution|0;const texture=_rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_0__.W.getOptimalTexture(bounds.width,bounds.height,resolution,!1);return texture.source.uploadMethodId="image",texture.source.resource=image,texture.source.alphaMode="premultiply-alpha-on-upload",texture.frame.width=width/resolution,texture.frame.height=height/resolution,texture.source.emit("update",texture.source),texture.updateUvs(),texture}},"./node_modules/pixi.js/lib/scene/text/utils/updateTextBounds.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{s:()=>updateTextBounds});var _utils_data_updateQuadBounds_mjs__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs");function updateTextBounds(batchableSprite,text){const{texture,bounds}=batchableSprite,padding=text._style._getFinalPadding();(0,_utils_data_updateQuadBounds_mjs__WEBPACK_IMPORTED_MODULE_0__.y)(bounds,text._anchor,texture);const paddingOffset=text._anchor._x*padding*2,paddingOffsetY=text._anchor._y*padding*2;bounds.minX-=padding-paddingOffset,bounds.minY-=padding-paddingOffsetY,bounds.maxX-=padding-paddingOffset,bounds.maxY-=padding-paddingOffsetY}},"./node_modules/tiny-lru/dist/tiny-lru.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{g:()=>lru});class LRU{constructor(max=0,ttl=0,resetTtl=!1){this.first=null,this.items=Object.create(null),this.last=null,this.max=max,this.resetTtl=resetTtl,this.size=0,this.ttl=ttl}clear(){return this.first=null,this.items=Object.create(null),this.last=null,this.size=0,this}delete(key){if(this.has(key)){const item=this.items[key];delete this.items[key],this.size--,null!==item.prev&&(item.prev.next=item.next),null!==item.next&&(item.next.prev=item.prev),this.first===item&&(this.first=item.next),this.last===item&&(this.last=item.prev)}return this}entries(keys=this.keys()){return keys.map(key=>[key,this.get(key)])}evict(bypass=!1){if(bypass||this.size>0){const item=this.first;delete this.items[item.key],0===--this.size?(this.first=null,this.last=null):(this.first=item.next,this.first.prev=null)}return this}expiresAt(key){let result;return this.has(key)&&(result=this.items[key].expiry),result}get(key){const item=this.items[key];if(void 0!==item)return this.ttl>0&&item.expiry<=Date.now()?void this.delete(key):(this.moveToEnd(item),item.value)}has(key){return key in this.items}moveToEnd(item){this.last!==item&&(null!==item.prev&&(item.prev.next=item.next),null!==item.next&&(item.next.prev=item.prev),this.first===item&&(this.first=item.next),item.prev=this.last,item.next=null,null!==this.last&&(this.last.next=item),this.last=item,null===this.first&&(this.first=item))}keys(){const result=[];let x=this.first;for(;null!==x;)result.push(x.key),x=x.next;return result}setWithEvicted(key,value,resetTtl=this.resetTtl){let evicted=null;if(this.has(key))this.set(key,value,!0,resetTtl);else{this.max>0&&this.size===this.max&&(evicted={...this.first},this.evict(!0));let item=this.items[key]={expiry:this.ttl>0?Date.now()+this.ttl:this.ttl,key,prev:this.last,next:null,value};1===++this.size?this.first=item:this.last.next=item,this.last=item}return evicted}set(key,value,bypass=!1,resetTtl=this.resetTtl){let item=this.items[key];return bypass||void 0!==item?(item.value=value,!1===bypass&&resetTtl&&(item.expiry=this.ttl>0?Date.now()+this.ttl:this.ttl),this.moveToEnd(item)):(this.max>0&&this.size===this.max&&this.evict(!0),item=this.items[key]={expiry:this.ttl>0?Date.now()+this.ttl:this.ttl,key,prev:this.last,next:null,value},1===++this.size?this.first=item:this.last.next=item,this.last=item),this}values(keys=this.keys()){return keys.map(key=>this.get(key))}}function lru(max=1e3,ttl=0,resetTtl=!1){if(isNaN(max)||max<0)throw new TypeError("Invalid max value");if(isNaN(ttl)||ttl<0)throw new TypeError("Invalid ttl value");if("boolean"!=typeof resetTtl)throw new TypeError("Invalid resetTtl value");return new LRU(max,ttl,resetTtl)}}}]);